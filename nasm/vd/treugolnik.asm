;Задача. На ввод подаётся три аргумента (три стороны треугольника), вычисляется площадь triangle'a. К сожалению, нет проверки "Существует ли вообще такой треугольник"  - просто выходит отрицательная площадь. 
;А вообще, если сумма любых двух сторон треугольника больше или равна третьей стороне, то такой треугольник не существует.  

%include "io64.inc" ;работаем в 64-разрядной системе
extern scanf ;подключаем шаблон функции из С scanf
extern printf ;подключаем шаблон функции из С printf
;extern sqrt   - это было лишнее
section .data ;раздел неизменяемых данных(констант)
scanf_format db "%lf %lf %lf", 0     ;вводим формат вызова функции из С scanf, он имеет такой вид, %l %l %l это  тип данных - числа с плавающей точкой , иначе double (что считываем - три аргумента плавающих чисел, т.е.три стороны), 0 это переход на новую строку с нажатием Enter(или пустая строка?, не знаю) 
printf_format db "Площадь треугольника: %g", 10, 0 ;формат вызова функции из С printf, %g - это  тип данных тоже числа с плавающей точкой (что печатаем - площадь треугольника, которая врядли будет целым числом) , 10 - это десятичная система счисления,  0 это переход на новую строку с нажатием Enter(или пустая строка?, не знаю) 

section .bss ;;раздел изменяемых данных(переменных)
a resq 1 ;создаём переменную а размером 1 qword(qwadry word), т.е. 1 квадри ворд это 8 байт, т.е. один восьмибайтовый
b resq 1 ;создаём переменную б размером также 8 байт
c resq 1 ;создаём переменную с размером также 8 байт, т.е. три стороны создали
S resq 1 ;создаём переменную S(это будет площадь треугольника) размером 8 байт

section .text ;секция текст программы
global CMAIN  ;глобальная основная функция CMAIN

CMAIN: 
enter 0, 0    ;пролог функции CMAIN, то же самое что и push rbp, mov rbp, rsp, нужно для профилактики ошибок(чтобы прога аварийно не завершалась)
lea rdi, [scanf_format]     ;принято соглашение (порядок регистров) о передаче ПАРАМЕТРОВ функций В РЕГИСТРЫ на языке Ассемблера, первый регистр (по соглашению) - rdi, получает сам формат вызываемой функции сканф(а если точнее, то первый аргумент - %l %l %l), хоть мы его и не вводим(как например второй аргумент), он является первым аргументом сканфа
lea rsi, [a]    ;второй, по соглашению, регистр rsi принимает второй аргумент - адрес вводимого аргумента а, так как функция в Си scanf("%l", &a), амперсанд & - это адрес вводимого числа с плавающей запятой а  (%l - число с плавающей запятой)
lea rdx, [b]   ;третий, по соглашению, аргумент(что есть адрес б) записывается в регистр edx
lea rcx, [c] ;четвёртый, по соглашению, аргумент(что есть адрес с) записывается в регистр rcx
call scanf           ;вызываем функцию scanf, она одновременно сканирует все три стороны наши а б с

;;cmpsd [a], [b+c]
;jg end
;cmpsd [b], [a+c]      } ----- это я закомментил (выделяете -> ПКМ -> закомментировать), как-то так надо сделать проверку на существование треугольника
;jg end
;cmpsd [c], [a+b]
;jg end
;
;end:
;PRINT_STRING "TREUGOLNIK NE SUSCHESTVUET"  ;или в дата msg ввести, и потом выводить....
;ret


;

mov rdi, [a] ;теперь для вызова нашей функции sqrt помещаем в регистры так же по соглашению, аргументы sqrt: а, б и с
mov rsi, [b] 
mov rdx, [c] 
call sqrt ;вызываем функцию sqrt, и перемещаемся сейчас в скрт


lea rdi, [printf_format] ;теперь мы будем вызывать функцию принтф, для этого передаем первый аргумент ея в рди по соглашению, опять таки, ....а первый аргумент есть адрес (формат), т.е. %g
;а где здесь передаётся второй аргумент??, который надо печатать(выводить на экран), т.е. площадь треугольника S, не знаю
mov rax, 1 ;это означает то же, что и return 1 , т.е. возращаемся, для успешного выхода из функции
call printf   ;теперь вызываем функцию, которая будет печатать 

xor rax, rax ;обнуляем рах
leave   ;эпилог для CMAIN
ret    ;реторн (возвращаемся из функции CMAIN)

sqrt: ;это функция скрт(корень), которая на самом деле вычисляет всю площадь треугольника по формуле Герона S=sqrt(p*(p-a)*(p-b)*(p-c))
enter 48, 0; это нужно для выравнивания стека, пролог функции: для хмм регистров нужно 16 байт, а у нас этих регистров 3 (мб не очень объяснение)   
movq xmm1, rdi  ;засовываем в хмм1 регистр рди, это был наш первый аргумент скрт, а
movq xmm2, rsi  ;засовываем в хмм2 регистр рси, это был наш второй аргумент скрт, б
movq xmm3, rdx  ;засовываем в хмм3 регистр рдх, это был наш третий аргумент скрт, с
    ;при работе с числами с плавающе точкой в ассемблере нужны хмм регистры и команды оканчивающиеся на -сд
    
    
mov [rbp - 8], rdi   ;запоминаем а
mov [rbp - 16], rsi ;запоминаем здесь б
mov [rbp - 24], rdx  ;запоминаем здесь с
    
addsd xmm1, xmm2 ;адд это сложение, суб - это вычитание, мул - это умножение, див - это дивижн, деление ; !! здесь везде это равноценно : хмм1=хмм1+хмм2
addsd xmm1, xmm3 ;в хмм1  сумма всех трех сторон 
mov r9, 2  ; помещаем в регистр р9 двойку
cvtsi2sd xmm5, r9    ;приведение типов, конвертация: int двойку преобразовываем в double два
divsd xmm1, xmm5 ;делим хмм1(периметр) на double два, получаем в хмм1 полупериметр р
    
movsd [rbp - 32], xmm1  ; здесь мы запомним, будет хранится полупериметр (из хмм1)
movsd xmm4, [rbp - 32] ;теперь полупериметр р в хмм4; хмм4 = р
subsd xmm4, [rbp - 8] ;отнимаем от полупериметра а : хмм4=р-а
movsd xmm5, [rbp - 32] ;хмм5 = р
subsd xmm5, [rbp - 16] ;отнимаем от полупериметра б : хмм5 = р - б
movsd xmm6, [rbp - 32];хмм6=р
subsd xmm6, [rbp - 24]    ;отнимаем от полупериметра с 6 хмм 6 = р -с 
    
mulsd xmm1, xmm4  ; хмм1 =  p * (p - a) 
mulsd xmm1, xmm5  ;  хмм1 = p * (p - a) * (p - b)
mulsd xmm1, xmm6     ; хмм1 =  p * (p - a) * (p - b) * (p - c)
movsd xmm0, xmm1 ; хмм0 = хмм1 = p * (p - a) * (p - b) * (p - c)

;как сам корень получается, я не понимаю
     
leave ; это эпилог функции (для выравнивания стека), то же самое что и mov rsp, rbp, pop rbp, для корректного выхода из функции
ret ;выходим из функции скрт
