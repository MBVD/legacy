

### **Виртуальная память**

Виртуальная память — это механизм, который используется в современных системах для управления доступом к памяти. Она позволяет абстрагировать физическую память и создать единое линейное адресное пространство, предоставляемое каждой программе.

### **Зачем нужна виртуальная память?**

1. **Изоляция программ**: Виртуальная память обеспечивает изоляцию программ друг от друга. Это позволяет одной программе работать без воздействия на данные другой, что улучшает безопасность и стабильность системы.

2. **Работа с адресным пространством большего/меньшего размера, чем физическая память**: Например, на 64-битной машине с 16 ГБ оперативной памяти можно запускать программы с 32-битной адресацией. Виртуальная память позволяет 32-битной программе использовать своё адресное пространство (до 4 ГБ), несмотря на то, что физическая память больше.

3. **Фрагментированная физическая память**: Виртуальная память делает возможным использование разрозненных областей физической памяти как одного непрерывного линейного пространства. Это позволяет эффективно выделять и освобождать память.

4. **Защита от ошибок программ**: Виртуальная память защищает от ошибок, когда программа пытается обращаться к запрещённым или неверным адресам. В таких случаях система может предотвратить повреждение данных.

### **Модель виртуальной памяти**

Виртуальная память может быть реализована различными способами:

1. **Сегментная модель**: В сегментной модели память делится на логические сегменты, каждый из которых может иметь свои права доступа и границы. Однако она не поддерживает легко разрывные линейные пространства, что ограничивает её гибкость.

2. **Страничная модель**: В страничной модели виртуальная память разбивается на блоки фиксированного размера, называемые страницами. Каждая страница отображается на блок физической памяти. Однако страничная модель может вызывать накладные расходы на управление адресами.

3. **Сегментно-страничная модель**: Это объединение обеих моделей. Она позволяет использовать как сегментирование для логического разделения памяти, так и страничную организацию для гибкости работы с разрывным адресным пространством. Этот подход используется в современных процессорах, поскольку он позволяет достичь баланса между эффективностью и гибкостью.

### **Работа процессора с виртуальной памятью**

Процессор не работает напрямую с физической памятью, он использует виртуальные адреса, которые необходимо преобразовать в физические. Это достигается через два блока: **сегментация** и **страничный блок**.

![[Pasted image 20240919211543.png]]

#### **Блок сегментации**

Процессор получает тройку данных (адрес, операция, сегмент), которые поступают в блок сегментации. Его задачи:
1. **Проверка разрешения на выполнение** операции.
2. **Проверка границ сегмента**: Если процесс выходит за пределы сегмента, это вызывает ошибку.

#### **Страничный блок**

После сегментации виртуальный адрес поступает в страничный блок, который сопоставляет его с физическим адресом.

1. **Page Fault**: Если запрашиваемый блок виртуальной памяти не отображен в физической памяти, происходит прерывание — page fault. Это не всегда ошибка: иногда часть программы или данных может быть выгружена на диск, и процессору нужно подождать её подгрузки в ОЗУ. В таких случаях операционная система занимается управлением выгрузкой и подгрузкой страниц памяти.

---

### **Пример работы процессора**

Пример инструкции:

```c
add rax, [rcx + 8 * rdx - 50]
```

1. **Извлечение инструкции**: Процессор получает инструкцию, используя регистр **RIP** (счётчик инструкций), который указывает на следующую команду для выполнения.
   
2. **Обработка сегментации**: Инструкция поступает в блок сегментации, где проверяется её сегмент (например, если это команда чтения из памяти). Блок проверяет, разрешена ли эта операция и находится ли адрес в допустимых границах сегмента.

3. **Обработка страничного блока**: Если всё корректно, страничный блок сопоставляет виртуальный адрес с физическим. Если адрес не отображён на физическую память, происходит page fault, и ОС занимается подгрузкой данных в ОЗУ.

![[Pasted image 20240919211658.png]]

### **Сегментная модель**

Сегментная модель — это метод организации памяти, при котором память делится на логические блоки, называемые сегментами. Каждый сегмент — это линейный участок памяти, который может быть непрерывным и обладать определёнными атрибутами доступа.

### **Основные концепции сегментной модели**

1. **Сегменты** — это участки памяти, которые могут быть выделены для программы или операционной системы. Они могут перекрываться или включать один сегмент в другой. Проблема заключается в том, что если требуется разместить новый сегмент, может потребоваться сдвиг уже существующих сегментов, чтобы освободить место. Этот процесс сталкивается с **проблемой внешней фрагментации**.

2. **Внешняя фрагментация** — это ситуация, когда в памяти остаются небольшие незанятые участки, но суммарно их недостаточно для размещения нового сегмента. Это вызывает сложности с управлением памятью, поскольку требуется перемещать большие участки, чтобы разместить новый. Однако это встречается редко, так как чаще используется страничная организация памяти.


	![[Pasted image 20240919211614.png]]


### **Таблица сегментов**

Для управления сегментами используется **таблица сегментов**, которая хранит информацию о всех доступных сегментах:

- В процессорах Intel существуют два регистра:
  - **GDTR** (Global Descriptor Table Register) — содержит адрес глобальной таблицы сегментов (используется ядром).
  - **LDTR** (Local Descriptor Table Register) — содержит адрес локальной таблицы сегментов (используется программами для создания своих сегментов).

Линукс, например, не использует **LDTR**, предпочитая управлять памятью иначе.

#### **Структура записи в таблице сегментов:**

1. **Base** (адрес начала) — начальный адрес сегмента. Это может быть как физический адрес, так и виртуальный (при использовании виртуальной памяти).
2. **Размер** — измеряется в "попугаях", для сокращения длины поля используется умножение на определённую единицу измерения (например, байты).
3. **Единица измерения** — указывает, в чём измеряется размер сегмента (байты, слова и т.д.).
4. **Разрешённые операции** — определяет права доступа к сегменту: чтение (read), запись (write), выполнение (execute), либо их комбинации (например, r/w).
5. **Тип сегмента** — указывает, для чего используется сегмент (например, для данных, кода и т.д.).
6. **Бит присутствия** — указывает, находится ли сегмент в памяти (если нет, происходит прерывание).
7. **Уровень привилегий** — минимальный уровень привилегий, необходимый для доступа к сегменту (например, ядро или пользователь).

---

### **Сегментные регистры**

Процессор использует специальные **сегментные регистры** для хранения номеров сегментов, чтобы указывать на нужные области памяти:

- **CS** (Code Segment) — хранит номер сегмента кода, из которого выполняются инструкции.
- **SS** (Stack Segment) — хранит сегмент стека, используемый для работы с данными в стеке.
- **DS** (Data Segment) — хранит сегмент данных, используемый для доступа к переменным и данным.
- **ES**, **FS**, **GS** — дополнительные сегментные регистры для специальных данных.

В каждом из этих регистров хранится **номер сегмента** и флаг, который указывает на присутствие сегмента в памяти.

---

### **Страничная память**

Страничная модель памяти используется для обеспечения эффективного управления памятью и защиты процессов. Она разделяет память на небольшие фиксированные блоки — **страницы** (в виртуальной памяти) и **фреймы** (в физической памяти). Страницы отображаются в фреймы, а неиспользуемые страницы могут быть выгружены в файл подкачки.

![[Pasted image 20240919211756.png]]
#### Основные характеристики:

1. **Физическая память** — диапазон адресов от 0 до \( M \).
2. **Виртуальная память** — диапазон от 0 до \( 2^n - 1 \).
   
Некоторые виртуальные адреса могут не быть отображены в физическую память. Это позволяет процессам работать с бóльшими объёмами памяти, чем доступно физически.

![[Pasted image 20240921095122.png]]

### **Иерархия таблиц страниц**

Для отображения виртуальных адресов в физические используется **таблица страниц**, которая хранит информацию о том, какие виртуальные адреса соответствуют каким физическим. 

1. **Разбиение виртуального адреса**: 
   - Старшие биты — это **индексы каталогов и таблиц** страниц.
   - Младшие биты — это **смещение внутри страницы**.
   
   Для 32-битных систем используется двухуровневая таблица страниц, а для 64-битных — иерархия из пяти уровней, что позволяет эффективно управлять огромным пространством адресов. 

   Виртуальный адрес делится на несколько диапазонов (например, по 10 и 12 бит), которые указывают на различные уровни таблиц страниц. Младшая часть — это смещение внутри страницы.

2. **Отображение страниц**:
   - **Большие и маленькие страницы**: В зависимости от архитектуры страницы могут быть разного размера, что сокращает количество уровней таблиц для больших страниц.

![[Pasted image 20240919212644.png]]
   
---

### **Что хранится в таблице страниц**

1. **Присутствие в ОЗУ** — указывает, загружена ли страница в оперативную память. Если нет, происходит прерывание (page fault), и страница загружается.
2. **Префикс физического адреса** — указывает на соответствующий фрейм в физической памяти.
3. **Тип страницы** — маленькая или большая страница. При больших страницах иерархия таблиц сокращается.
4. **Права доступа** — определяют, можно ли читать, писать или выполнять код на странице (R/W/X). Для 64-битных систем права могут задаваться на уровне страниц.
5. **Уровень привилегий** — определяет, доступна ли страница ядру или пользовательскому процессу.
6. **Приоритет ввода-вывода** — (возможно) указывает приоритет операции для страниц, использующихся в операциях ввода/вывода.
7. **Запрет сброса TLB** — позволяет управлять кэшированием страниц в буфере TLB (Translation Lookaside Buffer), чтобы избежать его сброса.
8. **Бит доступа** — указывает, что страница используется часто и её не следует выгружать из ОЗУ.
9. **Бит грязности** — устанавливается, если данные на странице изменились. Грязные страницы должны быть синхронизированы с внешними устройствами перед выгрузкой (например, записаны на диск).


### **TLB (Translation Lookaside Buffer)**

TLB (буфер ассоциативных преобразований) — это специализированная высокоскоростная кэш-память, используемая для ускорения процесса преобразования виртуальных адресов в физические при работе с виртуальной памятью. Его основная задача — уменьшить задержки, связанные с обращением к таблице страниц, которая используется для трансляции виртуальных адресов в физические.

![[Pasted image 20240919213219.png]]

### **Почему нужен TLB?**

Процессор работает с виртуальными адресами, которые необходимо преобразовать в физические для доступа к памяти. Это преобразование выполняется с помощью таблицы страниц, которая может иметь несколько уровней в современных процессорах (например, до пяти уровней в 64-битных системах).

Обращение к многоуровневой таблице страниц — это затратная операция, поскольку каждый уровень требует доступа к памяти. Для того чтобы сократить количество таких обращений и ускорить выполнение программ, в процессорах используется **TLB-кэш**. Он хранит уже выполненные преобразования виртуальных адресов в физические, позволяя повторно использовать их без обращения к таблице страниц.

### **Механизм работы TLB**

Когда процессор получает виртуальный адрес для выполнения операции (например, чтение или запись данных), происходит следующий процесс:

1. **Запрос в TLB**: Сначала процессор проверяет, есть ли преобразование этого виртуального адреса в физический уже в TLB. Если оно есть (это называется **TLB hit**), физический адрес сразу используется для доступа к памяти.
   
2. **Обращение к таблице страниц**: Если соответствие для виртуального адреса в TLB не найдено (**TLB miss**), процессор обращается к таблице страниц, которая находится в основной памяти, для выполнения преобразования.

3. **Обновление TLB**: После того как таблица страниц вернёт физический адрес для запрашиваемого виртуального адреса, это преобразование записывается в TLB для ускорения будущих обращений.


### **Особенности TLB**

1. **Размер**: TLB обычно имеет небольшой размер (десятки или сотни записей) по сравнению с другими кэшами, поскольку хранит только наиболее часто используемые преобразования.
   
2. **Ассоциативная память**: TLB использует ассоциативную память, которая позволяет эффективно искать соответствия виртуальных адресов физическим без необходимости проверки каждого элемента последовательно.

3. **Поддержка разных уровней привилегий**: TLB также учитывает уровень привилегий (кольца защиты) при выполнении преобразований. Если виртуальный адрес принадлежит сегменту, доступ к которому ограничен, TLB может запретить выполнение операции.

### **Виды TLB**

1. **Инструкционный и данные TLB (ITLB и DTLB)**: В некоторых процессорах существует разделение на TLB для инструкций и данных, так же как и в случае с кэшами инструкций и данных.
   
2. **Многоуровневый TLB**: В современных процессорах может быть несколько уровней TLB, как и в случае с кэшами данных. Первый уровень (L1 TLB) небольшой, но очень быстрый, а второй уровень (L2 TLB) больше и медленнее.

### **Проблемы и оптимизации TLB**

1. **TLB Miss**: Когда адрес не находится в TLB, происходит промах, и процессору приходится обращаться к таблице страниц. Это приводит к задержкам в выполнении программы. Для минимизации промахов современные процессоры используют разные стратегии кэширования и предсказания.

2. **Флеш TLB**: При переключении процессов или контекстов в операционной системе TLB может очищаться (флеш TLB), так как разные процессы имеют свои собственные таблицы страниц. Это снижает производительность, поэтому для некоторых процессоров предусмотрены механизмы для минимизации этих эффектов (например, использование тегов процессов в TLB).


---

### **Механизмы защиты памяти: Кольца защиты**

Кольца защиты — это механизм в процессорах, позволяющий разграничивать доступ различных частей программного обеспечения к ресурсам системы, таким как память, процессорное время, устройства ввода-вывода и пр. Этот механизм помогает предотвратить некорректное использование системных ресурсов и повысить безопасность.


### **Кольца защиты в архитектуре процессоров**

Современные процессоры (например, x86) используют четыре кольца защиты, где каждое кольцо соответствует определённому уровню привилегий:

![[Pasted image 20240919212723.png]]

- **Уровень 0 (Ring 0)** — **Ядро ОС** или **гипервизор**. Этот уровень имеет полный доступ к аппаратным ресурсам и управляет привилегиями других уровней. В некоторых случаях, особенно при использовании гипервизоров (например, Xen), на нулевом уровне работает минималистичное ядро, которое управляет виртуальными машинами.
  
  Пример гипервизора:
  - **Xen**: позволяет запускать несколько операционных систем на одном физическом сервере, причём каждое ядро ОС работает так, как если бы оно запускалось на отдельной машине, но с ограниченными привилегиями. Гипервизор на уровне 0 даёт ядрам ОС доступ к необходимым ресурсам и управляет их изоляцией друг от друга.

- **Уровень 1 (Ring 1)** — **Ядро операционной системы**. Этот уровень предназначен для выполнения критических функций ОС. В этом уровне происходят системные вызовы и взаимодействие с аппаратными ресурсами.

- **Уровень 2 (Ring 2)** — Промежуточный уровень, который часто не используется напрямую в современных ОС, но может быть применён для специфических задач, таких как драйверы или определённые сервисы.

- **Уровень 3 (Ring 3)** — **Пользовательские приложения**. Программы и процессы пользователя работают в этом уровне, не имея прямого доступа к ресурсам системы, таким как память или устройства ввода-вывода. Все обращения к системным ресурсам происходят через ядро с использованием системных вызовов (например, через инструкцию `syscall`).

### **Переход между уровнями привилегий**

Основной способ перехода между уровнями привилегий — это использование системных вызовов. Например, когда программа (уровень 3) хочет получить доступ к системным ресурсам, она обращается к ядру (уровень 1) с помощью **системного вызова**. В x86-архитектуре для этого используются инструкции вроде `syscall` или `int 0x80`.

Пример взаимодействия:
- Программа на уровне 3 вызывает системную функцию через `syscall`.
- Ядро на уровне 1 обрабатывает запрос и выполняет необходимые действия.
- После завершения работы управление возвращается обратно в программу на уровне 3.

### **Пример использования гипервизоров**

Гипервизоры (на уровне 0) позволяют запускать несколько операционных систем на одном физическом сервере, при этом каждая ОС работает в своём изолированном окружении. Это позволяет:
1. Экономить ресурсы и оптимизировать их использование.
2. Обеспечивать изоляцию между различными ОС, запущенными на одной машине.
3. Разделять физические ресурсы (процессорное время, оперативную память, устройства ввода-вывода) между виртуальными машинами.
