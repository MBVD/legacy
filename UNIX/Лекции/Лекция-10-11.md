
### Инвертированная таблица страниц

Если прямая таблица строится на основе виртуального адреса, то инвертированная таблица строится на основе физического адреса. Как она выглядит (РИСУНОК 1)? Её размер равен числу физических страниц в системе. В каждой записи инвертированной таблицы содержится:

1. Статус страницы (свободна/занята),
2. Виртуальный адрес, отображённый на эту физическую страницу,
3. Ссылка на иерархию таблиц страниц в виртуальной памяти ядра.

Почему нужна ссылка на виртуальную память ядра? Иерархия таблиц страниц может быть сложной и уникальной для каждого процесса. Как указано в «Машечкине», в таблице может храниться PID процесса, хотя это не всегда корректно. Важно, чтобы при обращении к странице можно было восстановить информацию о конкретной иерархии страниц для каждого процесса, что требует ссылки на данные, доступные ядру. 

Получаем следующую картину: таблица страниц отображает все физические страницы в ОЗУ. Когда виртуальные страницы отображаются на физические, в ОЗУ выделяются физические страницы, каждая из которых является частью физической памяти (РИСУНОК 2).

![[таблица_страниц_2024-09-21 10.51.52.excalidraw.png]]

ОЗУ разбита на физические страницы, которые могут быть разных размеров. Если в виртуальной памяти используются большие страницы, то в физической памяти они могут быть разбиты на несколько более мелких страниц. Это приводит к тому, что записи в инвертированной таблице могут быть одинаковыми для нескольких маленьких страниц (возможно, это спорный момент). Часть физической памяти может быть занята, часть — свободна. Однако, мы всегда знаем, кому конкретно принадлежит каждая физическая страница благодаря инвертированной таблице.

#### Запросы на выделение памяти

0. **Неявный запрос** — память, используемая для размещения кода ядра, системных данных и таблиц. BIOS уже размещает эту информацию в памяти до запуска ядра. Когда ядро создаёт инвертированную таблицу страниц, часть полей в ней помечена как занятая, поскольку эта память уже используется. Загрузчик размещает ядро как программу в ОЗУ, и оно продолжает занимать своё место в таблице.

1. **Запрос непрерывного пространства в ОЗУ**. Для обеспечения этого используется функция `kmalloc` и её комплементарная `kfree`. Они предоставляют функции динамического выделения и освобождения памяти.
  
2. **Запрос непрерывного участка в виртуальной памяти**. Здесь требуется, чтобы память была непрерывной в виртуальной памяти, но это необязательно должно отражаться в физической памяти. Для этого используются функции `vmalloc` и `vfree`.

### Запрос непрерывного участка

>[!Note] 
>buddy system — отдельный механизм управления памятью, связанный с инвертированной таблицей страниц.

Здесь начинают происходить более сложные процессы. Система выделяет три зоны: low, high и DMA. Для управления памятью в этих зонах используется специальный механизм — **buddy system**, который создается при загрузке ядра. Ядро заранее резервирует определённый непрерывный участок в ОЗУ (обычно не очень большой, порядка 2^10 страниц). Каждая из трёх зон (low, high и DMA) имеет собственную buddy system, которая контролирует выделение памяти в соответствующих областях. Все три области могут использоваться для операций DMA, поскольку для этого требуется физически непрерывный участок памяти. Причём, третья зона (DMA) может занимать всю память (РИСУНОК 4). 

В области low находится адрес < 2^16, и система резервирует определённые физические страницы, помеченные как занятые в buddy system. Этот механизм освобождает ядро от необходимости проверять, занята ли уже память, предоставляемая через `kmalloc`. Затем выделяется средняя область, называемая high, и в ней также используется непрерывная buddy system. Самой дефицитной является нижняя зона (low buddy), и если устройство может работать с средним диапазоном (high), то предпочтительно использовать его, чтобы избежать проблем с нехваткой пространства в низких диапазонах.

Функция `kmalloc` — это высокоуровневая функция, которая использует другие более низкоуровневые функции для управления памятью. Одной из таких функций является `get_free_pages`. 

Buddy system работает по принципу степеней двойки (РИСУНОК 5). Один блок памяти соответствует одной физической странице.

### Бинарная куча и построение дерева в buddy system (Алгоритм buddy system)

**Бинарная куча** — это структура данных, где для каждого узла гарантируется, что значения в поддеревьях правее всегда меньше, чем в поддеревьях левее. В **buddy system** используется схожий принцип построения, только вместо значений в узлах используются физические страницы памяти. 

![[algos2024-09-21 11.20.24.excalidraw.png]]

Алгоритм **buddy system** строит дерево, где каждый узел соответствует блоку памяти, кратному степени двойки. Начинаем с блока размера \(2^N\) (например, 16 страниц). Этот блок делится на два подблока по 8 страниц, и оба подблока помечаются как свободные. Далее, если поступает запрос, скажем, на 5 страниц, система смотрит, где есть свободный блок, например, в младших 8 страницах. Этот блок снова делится пополам, образуя два поддерева — одно на 4 страницы, другое на 4. Теперь один из этих подблоков может быть помечен как занятый, а другой — как свободный. 

Алгоритм продолжает делить блоки, пока не найдёт минимальный подходящий размер. В результате выделяется блок памяти, который кратен степени двойки, и возвращается адрес последнего занятого поддерева. В этом процессе используется функция `get_free_pages`, которая отвечает за выделение страниц. Память выделяется кратно странице, но запросы могут требовать блоки большего или меньшего размера.

### Slab — алгоритм. Slab system

**Slab system** решает проблему, когда память требуется для объектов, размер которых не кратен размеру страницы. Идея в том, чтобы создавать специальные списки (**slabs**), которые объединяют небольшие блоки памяти одинакового размера, но не обязательно кратные странице. Slab — это небольшой фрагмент памяти, а сама страница памяти может содержать несколько таких slabs.

![[Pasted image 20240922215036.png]]

Представьте плитку на полу: каждая плитка — это slab, а весь пол — это страница памяти. Когда система запрашивает выделение памяти через `kmalloc`, она ищет подходящий slab в уже выделенной странице. Если не удаётся найти подходящий slab, выделяется новая страница через `get_free_pages`, и в ней создаются новые slabs.

Таким образом, система работает с заранее определёнными размерами объектов, оптимизируя процесс выделения памяти. Когда вы вызываете `kmalloc(10 байт)`, система ищет slab подходящего размера и возвращает его адрес. Если свободного slab нет, выделяется новая страница. Slab system хорошо работает для частых мелких запросов на память, эффективно управляя фрагментами и минимизируя потерю памяти.

### Vmalloc

`vmalloc` — это функция, которая выделяет память в виртуальном адресном пространстве. Она пробегает по инвертированным таблицам страниц, находит незанятые блоки и выделяет память, пока не будет достигнут нужный размер. В процессе работы функция изменяет записи в каталоге страниц, который соответствует конкретному процессу, обеспечивая непрерывное адресное пространство в виртуальной памяти, даже если в физической памяти блоки могут быть разрознены.

### Неприятности

Какие могут возникнуть проблемы в процессе управления памятью? Главная неприятность — это нехватка физической памяти. Когда вы вызываете `kmalloc`, а памяти нет, система сталкивается с двумя возможными сценариями:

1) **Kernel Panic:** В этом случае запускается специальный код, для которого память заранее выделена. Он сообщает о проблеме и инициирует **Kernel Panic** — экстренное завершение работы системы, поскольку ядро не может продолжить свою работу без дополнительной памяти.
   
2) **OOM Killer:** Если система не может выделить память для ядра, запускается **OOM Killer (Out of Memory Killer)**. Его задача — освободить память, завершив один из работающих процессов. OOM Killer анализирует список процессов, чтобы выбрать "менее важный" процесс, который можно завершить. Программы, работающие от имени `root`, или системные процессы (с идентификатором пользователя меньше тысячи) обычно не убиваются. Выбор процесса может зависеть от нескольких факторов: занимаемая память, активность процесса и его важность для системы. Хотя кажется, что OOM Killer убивает процессы, которые занимают больше памяти, на самом деле его алгоритм гораздо сложнее и зависит от ряда показателей.

**Вопрос:** Какое действие в коде ядра может непосредственно привести к запуску OOM Killer?
**Ответ:** OOM Killer запускается, если после вызова `kmalloc` возвращается ноль, что означает невозможность выделить память.

### Overcommit

В системе может быть разрешён **overcommit** — стратегия, при которой операционная система выделяет больше виртуальной памяти, чем у неё есть физически. Это делается, исходя из предположения, что не вся выделенная виртуальная память будет использоваться. В результате, вызовы вроде `vmalloc` могут "лениво" выделять страницы памяти. Например, у вас есть виртуальное адресное пространство, и ваши данные могут располагаться в различных его участках. Вызовы `malloc`, `calloc` и `free` работают в этом пространстве. Когда вы увеличиваете область кучи с помощью системного вызова `brk`, вы расширяете виртуальное адресное пространство, к которому может обращаться программа.

Практически это означает, что ядро выделяет память, которая может фактически не использоваться. Этот механизм называется **overcommit**, и он позволяет использовать больше памяти, чем физически доступно. **Overcommit ratio** управляет тем, насколько сильно ядро может "перекоммитировать" память. Если система пытается использовать больше памяти, чем физически доступно, и не может её выделить, запускается OOM Killer.

### Buddy System и Slab Info

Системная информация о состоянии **buddy system** и **slab allocator** доступна в `/proc/buddy` и `/proc/slabinfo`. Эти файлы содержат данные о текущем состоянии выделения памяти и структуре памяти системы. В частности, они помогают понять, как организована виртуальная память и какие ресурсы остаются доступными для новых процессов и задач.

### Виртуальная память процессов и ядра

User space — это область виртуальной памяти, доступная для пользовательских процессов. Виртуальная память ядра (Kernel space) включает в себя и виртуальную память user space, что позволяет ядру взаимодействовать с процессами, но при этом ограничивает их возможности доступа к своим собственным данным.

![[userpace 2024-09-21 12.41.15.excalidraw.png]]

В самом низу виртуального адресного пространства находится страница с адресом 0. Эта страница, как правило, не отображена ни на какой реальный участок оперативной памяти. Это необходимо для того, чтобы при обращении к нулевому адресу возникал **segmentation fault**, защищая систему от случайных ошибок обращения к памяти через NULL указатели.

За этой областью следует большой сегмент, выделенный для ядра. Эта область защищена от записи со стороны пользовательских процессов, и любое обращение к ней извне (из user space) вызывает ошибки доступа. Виртуальная память ядра может находиться в совершенно другом месте, чем соответствующая область пользовательского пространства, для того чтобы предотвратить любые несанкционированные манипуляции с памятью ядра.

Дальше в структуре виртуальной памяти идут различные сегменты, относящиеся к пользовательским данным:
- **Код** программы (text segment) — неизменяемая часть памяти, где находятся инструкции программы.
- **Data segment** — область, содержащая инициализированные глобальные и статические переменные.
- **BSS (Block Started by Symbol)** — область для неинициализированных переменных.
- **Заголовок кучи** — метаданные, описывающие состояние динамически выделяемой памяти.

После этого идет куча — область памяти, выделяемая динамически с помощью функций `malloc` и `free`. Куча растет вниз, расширяя виртуальное адресное пространство.

Между кучей и стеком может находиться так называемая **область отображений файлов на память** (`mmap`). Эта область позволяет отображать файлы напрямую в виртуальное адресное пространство, что значительно ускоряет доступ к файлам и экономит ресурсы системы.

Виртуальная память может быть фрагментирована: после кучи часто образуются пустые участки, не отображенные на физическую память. Эта "дырка" от конца кучи до начала стека гигантская. Верхняя граница кучи помечена указателем **brk**, который может двигаться, изменяя границы кучи. При использовании `malloc` память может выделяться через изменение `brk`, либо через `mmap`.

Куча растёт вниз, начиная с точки, указанной в заголовке кучи, и управляется через механизм, известный как **brk**. Когда вы выделяете память через `malloc`, граница кучи может перемещаться, уменьшая виртуальные адреса (при освобождении памяти для ядра) или увеличивая их (при захвате памяти). **brk** может двигаться вниз для увеличения адресного пространства процесса.

![[userpace2 2024-09-21 12.53.19.excalidraw.png]]

При необходимости пользователь может запросить больше памяти для кучи, и тогда `brk` будет сдвигаться вниз (адреса будут увеличиваться), захватывая новые участки виртуального адресного пространства. В некоторых случаях, однако, выделение памяти может происходить через `mmap` вместо изменения `brk`.

Помимо этого, внутренняя организация памяти ядра схожа с пользовательской. На верхнем уровне находится **MMIO (Memory-Mapped I/O)**, за ним следует **код ядра**, далее **данные ядра**, и, наконец, **стек ядра**, который растет сверху вниз.

![[Pasted image 20240922220145.png]]


### SWAPPING (СВОППИНГ)

![[отображения 2024-09-21 13.08.27.excalidraw.png]]

**Чистая страница** — это страница, которая уже синхронизирована с жестким диском (HDD) и может быть выгружена из оперативной памяти без потерь данных.

**Грязная страница** — страница, которая не синхронизирована с HDD, и её данные в ОЗУ были изменены. Прежде чем выгружать такую страницу на внешний носитель, необходимо записать её обновленное содержимое на диск.

Суть своппинга заключается в том, что содержимое оперативной памяти (ОЗУ) может сохраняться на внешнем устройстве — как правило, на жестком диске. В данном случае ОЗУ выступает в роли кэша для жесткого диска, а объем своп-файла часто превышает размер самой оперативной памяти. В процессе работы системы виртуальная память используется как абстракция для хранения данных всех запущенных программ, и каждая страница виртуальной памяти может быть отображена либо в ОЗУ, либо на жесткий диск.

Жесткий диск, в отличие от ОЗУ, представляет собой долгосрочное хранилище, которое сохраняет данные даже после выключения системы. Однако запись и чтение с жесткого диска значительно медленнее, чем работа с оперативной памятью. Идея своппинга состоит в том, что когда в ОЗУ не хватает места для хранения всех страниц процессов, некоторые страницы могут быть выгружены на жесткий диск. Однако не все страницы могут быть выгружены — например, некоторые страницы ядра всегда должны оставаться в оперативной памяти.

Процесс своппинга может быть представлен несколькими ситуациями:

1. **Виртуальная память не отображена в оперативной памяти и находится на HDD.** 
   В этом случае, когда происходит обращение к странице, система ищет свободный диапазон в оперативной памяти или выбирает подходящую чистую страницу, которую можно выгрузить. После этого инициируется операция чтения страницы с жесткого диска. Этот процесс может быть выполнен не только страничным демоном, но и другими механизмами, если страница нужна срочно.

2. **Виртуальная память отображена в оперативной памяти и страница чистая.** 
   В этом случае ничего делать не нужно, всё в порядке. Страничный демон просто пересчитывает счетчики использования страниц для возможной выгрузки в будущем.

3. **Виртуальная память отображена в оперативной памяти, и страница грязная.**
   Если страница грязная, это значит, что её изменения ещё не синхронизированы с HDD. Необходимо инициировать операцию записи этой страницы на диск (например, через Direct Memory Access, DMA) по истечении определённого времени.

4. **Виртуальная память отображена в оперативной памяти, но отсутствует на HDD.**
   Это может указывать на два сценария:
   - Либо это страница ядра, которая не должна отображаться на HDD. Например, это может быть страница с важными данными (хешами, паролями), и её никогда не следует выгружать. Это нормальная ситуация, и она не требует вмешательства.
   - Либо это новая страница, которой ещё не было соответствия на жестком диске. В таком случае ей нужно назначить место на HDD и начать процесс синхронизации.

Всеми этими задачами управляет **страничный демон**. Это фоновый процесс, который работает через определенные интервалы времени и проверяет все страницы, находящиеся в ОЗУ, чтобы выполнить необходимые действия по их синхронизации с внешними носителями или освобождению места в оперативной памяти.

### Алгоритм выбора страницы для замещения

Для каждой страницы в системе может существовать до четырёх счетчиков, которые помогают страничному демону принимать решение о замещении страниц. Страничный демон периодически запускается по таймеру и отслеживает активность страниц. Когда страница была прочитана, демон обнуляет соответствующий счетчик, указывающий, сколько времени прошло с последнего чтения.

Вот основные счетчики:

1. **Число чтений.** Счетчик увеличивается, когда бит доступа установлен в 1, а бит грязности в 0. Это означает, что страница была прочитана, но не изменена.
2. **Число записей.** Счетчик увеличивается, когда страница была изменена (грязная страница). Здесь важно отслеживать, как часто данные страницы записывались в ОЗУ.
3. **Сколько времени прошло с последнего чтения.** Этот счетчик позволяет системе понять, как давно страница не использовалась для чтения.
4. **Сколько времени прошло с последней записи.** Аналогично предыдущему счетчику, этот фиксирует, как давно страница не обновлялась.

![[параметры 2024-09-21 13.49.03.excalidraw.png]]

### Стратегии замещения страниц:

1. **FIFO (First-In, First-Out).** 
   Это простейший механизм, при котором страницы замещаются в порядке их поступления. Однако проблема в том, что он не учитывает частоту использования страницы, и есть вероятность, что недавно ставшая популярной страница будет выгружена.

2. **LRU (Least Recently Used).** 
   Этот алгоритм замещает страницу, которая дольше всех не использовалась. Он пытается предсказать, что страница, не используемая в течение длительного времени, не понадобится в ближайшем будущем.

3. **NRU (Not Recently Used).** 
   Стратегия делит страницы на четыре класса, основываясь на битах доступа и грязности. Она выбирает для замещения страницы, которые реже всего использовались или не изменялись в последнее время.

4. **Алгоритм часов.** 
   Это оптимизация LRU, в которой страницы организованы в виде кольца, а указатель (стрелка) перемещается по кругу, проверяя биты доступа. Если страница не использовалась недавно (бит доступа равен 0), она становится кандидатом на замещение. Если бит равен 1, он сбрасывается в 0, и указатель двигается дальше.

Эти алгоритмы помогают операционной системе эффективно управлять памятью, уменьшая количество обращений к медленным внешним устройствам (HDD) и обеспечивая быструю работу часто используемых страниц.

![[метрика 2024-09-21 14.04.48.excalidraw.png]]