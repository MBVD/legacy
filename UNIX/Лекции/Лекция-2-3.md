
>[!note] Определение
>В контексте данной лекции под **Вычислительной Системой** мы будем понимать абстрактное представление компьютера. Это все, с чем мы взаимодействуем при работе с компьютером.


### Уровни вычислительной системы

**0 уровень — Уровень "железа"**  
Это физический уровень, который представляет собой аппаратное обеспечение компьютера: процессор, память, устройства ввода-вывода и прочие компоненты. С точки зрения программиста, этот уровень имеет свои законы и ограничения, но непосредственно его программировать мы не можем. Например, наличие силовых кабелей на 220 В не важно для программиста, однако это влияет на работу системы в целом.

**1 уровень — Аппаратный уровень**  
Этот уровень предоставляет возможности для программирования. Именно с него начинается наше взаимодействие с вычислительной системой как программистов. Аппаратный уровень содержит устройства, которые предоставляют интерфейсы для взаимодействия с ними. Например, видеокарта имеет стандартизированные способы передачи данных, благодаря которым можно написать универсальные программы для работы с любой видеокартой.

**2 уровень — Управление физическими ресурсами**  
На этом уровне операционная система управляет физическими ресурсами компьютера. Он переводит низкоуровневые команды аппаратуры в более универсальные понятия, доступные ядру операционной системы. Например, если подключить жесткий диск, ОС предоставит его как блочное устройство, с которым можно работать на уровне файловой системы.

**3 уровень — Управление виртуальными ресурсами**  
Этот уровень занимается управлением логическими ресурсами. Аппаратные компоненты представляются в виде абстрактных понятий, с которыми можно оперировать. Например, здесь появляются такие понятия, как файлы, процессы, пользователи. Взаимодействие с ними осуществляется через интерфейсы, предоставляемые операционной системой.

**4 уровень — Управление системами программирования и интерфейсами**  
Здесь расположены инструменты для разработки программного обеспечения и интерфейсы для взаимодействия программ с операционной системой. Этот уровень обеспечивает работу кода программ и их взаимодействие с ОС.

**5 уровень — Уровень системных программ**  
На этом уровне находятся системные программы и библиотеки.  
5.1. Библиотеки: обеспечивают доступ к базовым функциям и ресурсам ОС для программ.  
5.2. Прикладные программы: это программы, которые непосредственно используются пользователями для выполнения различных задач.



### Взаимодействие пользователей с вычислительной системой

Пользователи (или "человечки") могут выполнять разные роли. Условно их можно разделить на две категории:

1. **Пользователи-домохозяйки** — это те, кто используют прикладные программы, не вникая в детали работы операционной системы и аппаратуры. Например, ученый, использующий пакеты для вычислений в ядерной физике, может не разбираться в том, как работает операционная система.
2. **Системные администраторы (сисадмины)** — это пользователи, которые управляют как системными, так и прикладными программами. Они глубже понимают структуру вычислительной системы и могут взаимодействовать с низкоуровневыми компонентами системы для настройки и оптимизации её работы.

### Классификация уровней

Ядро операционной системы начинается с физического уровня и охватывает уровни до конца уровня виртуальных ресурсов. Оно обеспечивает управление ресурсами и взаимодействие между программами и аппаратными устройствами.

#### Программный интерфейс

Различные уровни системы взаимодействуют друг с другом через ***механизмы системных вызовов***. Это механизм, через который программы могут обращаться к ядру, чтобы запросить выполнение различных функций. Например, ядро способно понимать, с какими программами и процессами оно должно взаимодействовать. При запуске исполняемого файла ядро может менять свои настройки или взаимодействовать с процессами. Системные вызовы обеспечивают связь между прикладными программами и ядром операционной системы.

Файловая система в операционных системах UNIX-подобного типа организована по определённой структуре, например:

```bash
/prog
/sys
/dev
```

Эти каталоги отражают организацию системных файлов и устройств. Например, каталог `/sys` содержит информацию о подключённых устройствах:

```bash
/sys -> /bus
```

Этот путь расскажет вам, какие устройства в данный момент подключены к системе. 

В Linux есть системная программа, которая называется `udev`, и она играет важную роль в управлении подключёнными устройствами.

```c
udev — "это системная программа, которая отслеживает изменения в каталоге /sys. Когда появляется новое физически подключённое устройство, udev понимает, что это за устройство, регистрирует файл устройства и загружает драйвер для его работы в ядро."
```

Таким образом, весь второй уровень можно рассматривать как уровень ***драйверов устройств***. Именно здесь обеспечивается взаимодействие с физическими ресурсами через абстракции драйверов. 

#### Уровни системного программирования и ядро

Ядра операционных систем могут отличаться, как в случае **FreeBSD**, **macOS** и других. Каждое ядро имеет свои особенности и интерфейсы. Однако при разработке программ существует задача обеспечить их совместимость с разными операционными системами. Компилятор сам по себе не знает, на какой операционной системе будет работать программа, и для решения этой задачи существуют специальные механизмы, которые позволяют абстрагироваться от конкретной ОС.

Примером такого механизма является **libc** — это стандартная библиотека, которая присутствует во всех UNIX-подобных системах. Она содержит интерфейсы для системных вызовов, что позволяет программам взаимодействовать с ядром ОС независимо от конкретной реализации ОС. В **libc** присутствуют функции, которые обращаются к системным вызовам на уровне ассемблера.

Пример системного вызова в UNIX:

```nasm
mov rax, <операция>
syscall
```

Этот код вызывает системную функцию, передавая операцию через регистр `rax`
Таким образом, можно писать программы, которые будут работать на разных операционных системах, используя универсальные вызовы ОС.

>[!tip] Замечание
>Библиотека **libc** является обязательной частью любой UNIX-подобной системы и предоставляет необходимый интерфейс для системных вызовов.


---

### Интерфейсы

1. **Формат бинарных файлов**  
   В Linux за работу с бинарными файлами отвечает ряд утилит, таких как:
   - **nm** — выводит таблицу символов исполняемого файла.
   - **hexdump** — показывает содержимое файла в шестнадцатеричном формате.
   - **addr2line** — преобразует адреса в файле в строки исходного кода.
   - **as** — это ассемблер, который преобразует код в машинные инструкции.
   - **ld** — компоновщик, связывающий объектные файлы для создания исполняемых.
   - **ar** — архиватор для создания и работы с архивами объектных файлов.
   - **ld.so** — динамический компоновщик, который загружает необходимые библиотеки при запуске программы.
   - **readelf** — позволяет анализировать заголовки и содержимое ELF-файлов (исполняемых файлов).

2. **Интерфейс системных вызовов**  
   Системные вызовы в Linux и других UNIX-подобных системах осуществляются через ассемблерные команды. Это включает:
   - **Номер прерывания** — уникальный идентификатор для каждого системного вызова.
   - **Параметры системного вызова** — передаются через определённые регистры процессора.
   - **Возврат результата** — результат системного вызова возвращается через регистр, обычно `rax` в архитектуре x86-64.

3. **Специальные файлы**  
   В UNIX вместо создания большого числа отдельных системных вызовов для управления устройствами была внедрена концепция **системных файлов**:
   - **/sys** — содержит информацию о подключённых устройствах и системных ресурсах.
   - **/dev** — представляет устройства в виде файлов, через которые можно взаимодействовать с физическим оборудованием.
   - **/proc** — виртуальная файловая система, которая отображает процессы и другую системную информацию в виде файлов.

4. **Системы программирования**  
   Уровень систем программирования включает инструменты и утилиты, необходимые для разработки, отладки и выполнения программ. Он опирается на интерфейсы операционной системы и системные вызовы.

### Уровень систем программирования (компоненты)

1. **Текстовый редактор**  
   Текстовые редакторы используются для написания исходного кода. Они могут находиться в другой системе, их использование не является обязательным, но они помогают в создании и редактировании кода. Примеры: **Vim**, **Emacs**, **Nano**.

2. **Компиляторы**  
   Компилятор переводит исходный код на высоком уровне в ассемблерный код, который понимает ядро операционной системы. Компиляторы работают с разными языками программирования и позволяют преобразовать код в машинные инструкции для выполнения процессором.

3. **Отладчики**  
   Отладчики помогают разработчикам находить и исправлять ошибки в программном коде. Некоторые примеры отладчиков:
   - **gdb** — отладчик для пошаговой отладки программ. Он может создавать "core" файлы для постмортем-отладки (посмертный дамп программы, аварийно завершившейся).
   - **valgrind** — утилита для отладки памяти, отслеживает ошибки при доступе к памяти, утечки и другие проблемы.
   - **Отладка ядра** — специализированные инструменты для отладки работы ядра операционной системы.
   - **gprof** — инструмент для анализа производительности программ, позволяет отслеживать время выполнения различных частей кода.

### Системные библиотеки и прикладные библиотеки

Системные библиотеки, такие как **libc**, являются стандартом для любой UNIX-подобной системы. **libc** предоставляет программам базовые функции и интерфейсы для системных вызовов, которые используют операционная система и ядро.

Отвечу как эксперт в операционных системах и системных утилитах. Я структурирую и объясню каждую команду и концепцию, чтобы текст был понятен и пригоден для сдачи экзамена.

---

### Системные утилиты

1. **Тактовая частота процессора и управление вентилятором**  
   Существует утилита **cpufreq** (или **cpufrequtils**), которая позволяет управлять тактовой частотой процессора. Это может быть полезно для настройки энергопотребления и производительности системы. Также можно управлять скоростью вентилятора, используя команды BIOS или сторонние утилиты (например, **lm-sensors**), которые позволяют контролировать датчики системы.

2. **Управление загрузкой ОС**  
   Существует несколько загрузчиков операционной системы:
   - **GRUB (grab)** — это наиболее распространённый загрузчик для Linux, который поддерживает множество операционных систем.  
     Команда: `grub-install` — используется для установки загрузчика.
   - **Yaboot** — старый загрузчик для PowerPC систем.
   - **LILO** — старый загрузчик, который редко используется на современных системах.
   - **Syslinux** — простой загрузчик, который часто используется на Live USB системах.
   
   Утилиты управления системой, которые используются на разных этапах запуска и выключения:
   - **init** — это первая программа, запускаемая после загрузки ядра. Она управляет запуском других процессов.
   - **shutdown** — утилита для выключения системы. Например, `shutdown -h now` выключит компьютер, а `shutdown -r now` перезагрузит его. Она позволяет задать задержку перед выключением.
   - **reboot** — утилита для перезагрузки системы.
   - **halt**, **poweroff** — остановка и выключение системы соответственно.

3. **Настройки терминалов**  
   Для управления терминалами используются следующие программы:
   - **mingetty**, **agetty**, **ingetty** — это утилиты для управления терминальными сессиями, которые связывают физический или виртуальный терминал с пользовательским интерфейсом.
   - Терминальные настройки часто хранятся в файлах конфигурации, которые задают поведение отображения символов на экране и ассоциации с кнопками (например, **termcap** — файл для описания возможностей терминалов).

4. **Загрузка дополнительных компонентов ядра**  
   Для работы с модулями ядра Linux используются следующие команды:
   - **modprobe** — загружает модуль ядра и его зависимости.
   - **rmmod** — удаляет модуль ядра.
   - **lsmod** — показывает список загруженных модулей.
   
   Дополнительно:
   - **lspci** — отображает информацию о подключённых PCI устройствах.
   - **lsusb** — отображает информацию о подключённых USB устройствах.

5. **Настройка сети**  
   В Linux есть несколько уровней работы с сетью:
   - **Network Manager** — высокоуровневая утилита для настройки сети. У неё есть графический интерфейс и текстовый (через **nmtui**).
   - **ip** — низкоуровневая утилита для управления сетевыми интерфейсами. Она позволяет выполнять команды:
     - **ip address** — показывает IP-адреса сетевых интерфейсов.
     - **ip route** — управляет маршрутами сети.
     - **ip link** — управляет физическими свойствами сетевых интерфейсов (включение/выключение интерфейсов, настройка пропускной способности и т.д.).
   
   Дополнительные старые команды:
   - **ifconfig** — старый инструмент для настройки сетевых интерфейсов.
   - **route** — старый инструмент для управления маршрутами.
   - **arp** — утилита для просмотра и изменения ARP таблицы (сопоставление IP-адресов с MAC-адресами).
   - **netstat** — показывает сетевые соединения и статистику.

   Полезные опции:
   - `-a` — показывает все соединения и интерфейсы.
   - `-p` — показывает, какой процесс связан с сетевым соединением.

   Другие утилиты:
   - **whois** — показывает информацию о владельце домена или IP-адреса.
   - **TCPdump** — захватывает и анализирует сетевой трафик.
   - **nmap** — утилита для сканирования сети и обнаружения устройств.
   - **dig** — утилита для запросов к DNS.
   - **nft** — утилита для управления сетевыми фильтрами (firewall).
   - **firewall-cmd** — для настройки firewall в Linux (например, в CentOS, Fedora).

   Для работы с Wi-Fi:
   - **iwlist** — показывает доступные точки доступа Wi-Fi.
   - **iwconfig** — позволяет настроить беспроводные сетевые интерфейсы.
   - **wpa_supplicant** — утилита для настройки шифрованных Wi-Fi соединений.

6. **"Жесткие диски" и файловые системы**  
   Устройства хранения данных могут быть представлены как жёсткие диски или SSD. Первым шагом при работе с диском является создание **таблицы разделов**. Для этого используются:
   - **fdisk** — утилита для создания и управления разделами на жёстких дисках.
   - **cfdisk** — интерфейсный вариант `fdisk`.
   - **sfdisk** — скриптовый вариант `fdisk`, который позволяет автоматизировать создание разделов.

   После создания таблицы разделов необходимо создать **файловую систему**:
   - **mkfs.ext2**, **mkfs.ext3**, **mkfs.ext4** — создание файловых систем ext.
   - **mkfs.ntfs** — создание файловой системы NTFS.
   - **fsck** — утилита для проверки и исправления ошибок в файловых системах.

   Дополнительные утилиты:
   - **tune2fs** — инструмент для настройки файловых систем ext.
   - **hdparm** — утилита для настройки параметров жёсткого диска.

   Команды для работы с дисками и файлами:
   - **mount** — примонтировать файловую систему.
   - **umount** — отмонтировать файловую систему.
   - **mv**, **rm**, **cp** — перемещение, удаление и копирование файлов соответственно.
   - **touch** — создание пустого файла.
   - **mkdir**, **rmdir** — создание и удаление директорий.
   - **ln** — создание жёстких и символических ссылок (опция `-s` для символической ссылки).
   - **chmod** — изменение прав доступа к файлам.
   - **chown** — изменение владельца файлов.

7. **Работа с пользователями**  
   Файлы конфигурации пользователей:
   - **/etc/passwd** — содержит информацию о пользователях.
   - **/etc/shadow** — содержит хэшированные пароли.
   
   Основные команды для работы с пользователями:
   - **useradd**, **adduser** — добавление нового пользователя.
   - **deluser** — удаление пользователя.
   - **groupdel** — удаление группы.
   - **passwd** — изменение пароля пользователя.
   - **chfn** — изменение информации о пользователе (например, имя, телефон).
   - **who** — показывает, кто в данный момент вошёл в систему.
   - **whoami** — показывает, под каким пользователем вы сейчас работаете.

---

### Установка ПО

1. **Команды для временного повышения прав**:
   - **su** — эта команда позволяет временно стать другим пользователем, чаще всего — пользователем **root**. Для этого нужно ввести пароль root. Например, `su -` переключит пользователя на root и откроет новую сессию с правами суперпользователя.
   - **sudo** — позволяет выполнять отдельные команды от имени **root** без необходимости перехода в сессию root. Пароль вводится только для одной команды, а не для всей сессии. Например, `sudo apt update` выполнит обновление пакетов с правами суперпользователя.

2. **Пакетные менеджеры и форматы пакетов**:
   Программное обеспечение в Linux обычно поставляется в виде пакетов. Два популярных формата пакетов:
   - **rpm** (Red Hat Package Manager) — используется в таких дистрибутивах, как Red Hat, CentOS, Fedora.
   - **deb** (Debian Package) — используется в таких дистрибутивах, как Debian, Ubuntu.

   Пакеты содержат:
   1. **Файлы с метаинформацией** — эта информация включает описание пакета, его зависимости и другую информацию.
   2. **Файлы с контрольными суммами** — используются для проверки целостности пакета.
   3. **Скрипты для установки** — набор команд, которые выполняются при установке, удалении или обновлении пакета.

3. **Этапы установки пакетов**:
   Процесс установки пакета может включать несколько этапов:
   1. **unpack** — распаковка содержимого пакета.
   2. **preinstall** — выполнение скриптов перед установкой.
   3. **install** — копирование файлов и установка программ.
   4. **post install** — выполнение скриптов после установки.
   5. **pre rm** — выполнение скриптов перед удалением.
   6. **rm/uninstall** — удаление пакета.
   7. **post rm** — выполнение скриптов после удаления.
   8. **purge** — полное удаление пакета и всех его конфигурационных файлов.

4. **Содержимое пакетов**:
   Каждый пакет содержит следующие важные данные:
   - **Название пакета** — уникальное имя для идентификации пакета.
   - **Полное название пакета** — включает версию, архитектуру и другую информацию (например, `nginx-1.18.0-1.el7.x86_64`).
   - **Описание пакета** — краткое описание того, что делает этот пакет.
   - **Версия пакета** — версия программного обеспечения, содержащегося в пакете.
   - **Список зависимостей**:
     - **Depends** — обязательные зависимости, которые должны быть установлены для работы пакета.
     - **Suggests** — необязательные пакеты, которые могут расширить функциональность.
     - **Recommends** — пакеты, которые рекомендуется установить, но они не являются обязательными.
     - **Conflicts** — пакеты, которые несовместимы с данным пакетом.
     - **Breaks** — пакеты, которые будут сломаны, если установить данный пакет.
