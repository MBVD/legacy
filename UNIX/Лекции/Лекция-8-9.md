
### **Уровни привилегий**

Информация о текущем уровне привилегий хранится в нескольких местах: в сегментах, страницах, дескрипторах прерываний и регистрах флагов. В регистре флагов записан текущий уровень привилегий, который программа изменить не может. При обращении к сегменту или странице проверяется текущий уровень привилегий, и если он меньше или равен уровню привилегий сегмента или страницы, доступ разрешается. В дескрипторе прерываний также содержится информация о привилегиях, и в момент вызова прерывания в регистр флагов записывается соответствующий уровень привилегий.

### **Прерывания**

Прерывания служат для реакции на определённые события, позволяя запускать сторонний код — **обработчик прерываний**, который решает возникшую ситуацию. Прерывания могут быть двух видов:

1. **Внутренние** — генерируются схемами процессора.
2. **Внешние** — приходят от внешних устройств.

**Внутренние прерывания** делятся на два типа:
- **Прерывания** — сигнализируют о событиях внутри процессора.
- **Исключения** — также являются прерываниями, но дополнительно передают информацию, например, адрес ошибки при возникновении исключения (например, `segmentation fault` записывается в контрольный регистр).

#### **Обработка прерываний**

Для работы с прерываниями используются:

- **Регистр прерываний** — хранит информацию о векторе прерываний.
- **Регистр маски прерываний** — позволяет запрещать определённые прерывания (в Intel эта функция реализована через флаг в регистре).
- **Таблицы дескрипторов прерываний** — в Intel это **IDT** (Interrupt Descriptor Table), а регистры, указывающие на IDT, называются **IDTR**.

Дополнительно:

1. **TSS** — сегмент, который используется для переключения контекста (в Intel это реализовано через TSS-регистры).

**Сценарии прерываний**:

![[Pasted image 20240921091436.png]]

Когда выполняется программа, её **instruction pointer** (IP) указывает на следующую инструкцию, и текущее выполнение происходит. Существует два варианта:

1. Инструкция может сама вызывать прерывание, в этом случае она не завершается, и процессор переключается на обработку прерывания.
2. Инструкция завершается, и затем запускается обработчик прерываний.

**Обработчики прерываний** могут быть двух видов:

1. **Короткие (близкие) прерывания**. Программа просто переходит на обработчик без маскирования последующих прерываний. При этом в стек сохраняются регистры, включая **IP** и флаги. Вектор прерываний указывает на новый **instruction pointer** (RIP), который находится в IDT, и выполняется новый код. Стек остаётся прежним, а возврат происходит через команду **iret**, которая восстанавливает состояние процессора до прерывания.

![[Pasted image 20240921091607.png]]

2. **Длинные (далёкие) прерывания**. При этом происходит переключение на другой стек. В таблице IDT (Interrupt Descriptor Table) записаны адрес обработчика и новый сегмент кода. Если требуется переключиться на другой стек, используются указатели на новые стеки для разных уровней привилегий. В некоторых архитектурах, например в 64-битных Intel, TSS может содержать указатели на стеки для всех уровней привилегий.

---

### **Важные элементы для работы с прерываниями**

1. **Вектор прерываний** — регистр, который хранит информацию о всех прерываниях (скрыт от программиста).
2. **Регистр маски прерываний** — запрещает или разрешает обработку конкретных прерываний.
3. **NMI (немаскируемые прерывания)** — прерывания, которые всегда обрабатываются, независимо от маски.

### **Последовательность обработки прерываний**

1. **Аппаратная стадия**:
   1. Маскирование всех прерываний.
   2. Сохранение текущей точки выполнения.
   3. Передача управления обработчику прерывания (установка нового IP).

2. **Программная стадия**:
   1. Сохранение всех регистров, которые могут измениться.
   2. Выполнение срочных действий (важно, что обработка других прерываний запрещена).
   3. Снятие маски прерываний.
   4. Выполнение несрочных действий (например, обновление таймеров).
   5. Восстановление регистров.
   6. Вызов **iret** — возврат в исходную программу или переключение на другую.

### **Проблемы с обработкой прерываний**

1. **Переполнение стека** — возникает, когда слишком много прерываний обрабатывается рекурсивно, что может привести к переполнению стека.
2. **Ошибочное маскирование** — забыли снять маску после завершения работы обработчика.
3. **Склеивание событий** — если произошло несколько прерываний одного типа, можно пропустить некоторые из них.
4. **Возврат не туда** — ошибка в номере сегмента при возврате может привести к ошибке в переключении контекста.

### **Таймер (часы)**

#### **Аппаратные таймеры**

Современные системы содержат несколько типов таймеров, встроенных в "железо", которые отвечают за синхронизацию времени:

1. **Момент включения**. Это таймер, который начинает отсчет с момента включения системы и работает в реальном времени (астрономическом). Его работа не зависит от тактовой частоты процессора, и он работает на фиксированной частоте.
   
2. **Отсчёт числа тактов с момента включения**. Этот таймер отслеживает количество тактов процессора и, как любой счётчик, может переполняться при достижении максимального значения.

3. **Внешние часы (астрономическое время)**. Внешние часы имеют низкую разрешающую способность, то есть они менее точные. Для повышения точности используются специальные платы, однако синхронизация всё равно может быть неидеальной. Для синхронизации времени в сетевых системах используется протокол PTP (Precision Time Protocol), который позволяет подключать таймеры с высокой разрешающей способностью к сетевой карте. Тем не менее, эти таймеры нельзя использовать для высокоточных задач, таких как исследование стадий ядерного взрыва. Эти медленные внешние часы поддерживаются батарейкой, встроенной в материнскую плату.

#### **Прерывание по таймеру**

Таймер с высокой разрешающей способностью отвечает за генерирование прерываний, когда происходит увеличение его значения на +1. Разрешающая способность таймера измеряется в наносекундах. При каждом прерывании по таймеру ядро операционной системы работает с набором таймеров, состоящим из двух ключевых чисел:

1. **Текущее значение таймера**.
2. **Значение, на котором должно произойти срабатывание**.

Идея заключается в том, что обработчик прерывания перебирает массив пар этих чисел и обновляет соответствующие счетчики. Если текущее значение таймера совпадает с требуемым значением, то генерируется дополнительное прерывание. Обработчик прерываний выполняет необходимые действия с таймером. Таким образом, таймер становится механизмом, обеспечивающим периодические прерывания внутри ядра. Чем реже таймер реагирует на изменения, тем больше таких таймеров можно использовать для других задач.

---

### **NMI — немаскируемое прерывание**

NMI (Non-Maskable Interrupt) — это прерывание, которое не может быть заблокировано маскировкой и всегда должно быть обработано системой. Их может быть несколько. Кроме того, существует **watchdog** — специальный таймер для контроля состояния системы.

Watchdog представляет собой счётчик, который увеличивается с каждым тактом. В начале его значение равно 0, а как только оно достигает определённого значения (например, 1024), происходит немаскируемое прерывание. Watchdog существует в двух вариантах:

1. **Watchdog на материнской плате**. Этот таймер используется для защиты от аппаратных зависаний. Если программа не сбросила его значение обратно в 0, то по достижении максимального значения watchdog активируется и может привести к отключению питания системы.

2. **Watchdog внутри ядра**. Этот таймер используется для диагностики и отладки работы самого ядра. Если ядро "зависло", то немаскируемое прерывание от watchdog запускает синий экран смерти (в случае операционных систем типа Windows).

Важно отметить, что некорректная работа с прерываниями или игнорирование watchdog может привести к катастрофическим сбоям в системе, и таких watchdog'ов может быть несколько, каждый из которых отвечает за свои задачи.\


### **Внешние прерывания**

#### **Эволюция контроллеров прерываний**

В начале был **IC** (Interrupt Controller). Затем пришел **PIC** (Programmable Interrupt Controller), а после него — **OPIC** (Open Programmable Interrupt Controller), оба контроллера работали с PCI шиной. В дальнейшем развитие прерываний перешло на **MSI** (Message Signaled Interrupt) с шиной PCI Express, а позже — на **MSI-X**, с расширенными возможностями для работы с прерываниями.

#### **IC — Interrupt Controller**

	![[Pasted image 20240921092057.png]]

На ранних стадиях развития компьютеров использовались аппаратные контроллеры прерываний. Эти контроллеры были аналоговыми и цифровыми одновременно. Например, у процессора был IC, от которого к каждому устройству и каждому слоту на материнской плате шли отдельные физические провода. Если взглянуть на плату с устройствами, это была **ISA шина** (Industry Standard Architecture). Шина имела несколько линий для передачи прерываний — обычно восемь, каждая линия соответствовала отдельному устройству, и замыкание провода активировало прерывание.

Каждая линия связывалась с определённым битом в регистре прерываний. В случае активации провода регистр указывал на номер прерывания, который был связан с внешним устройством через IC. Со временем IC стал более сложным, превратившись из одной микросхемы в две, которые позже были встроены в процессор. На этом этапе IC трансформировался в **PIC**.

![[Pasted image 20240921092157.png]]

С появлением PIC необходимость в ручной настройке через джамперы отпала. Теперь прерывания назначались программно через регистр. Вместо фиксированного соответствия проводов и прерываний появилась возможность программировать, какое устройство должно вызвать какое прерывание, что упростило работу с множеством устройств.

#### **OPIC — Open Programmable Interrupt Controller**

OPIC был следующим шагом, поддерживающим многопроцессорные системы. В этой архитектуре появился **LPIC** (Local Programmable Interrupt Controller) и **APIC** (Advanced Programmable Interrupt Controller) — отдельные компоненты для каждого процессора. Переход на цифровую форму передачи сигналов позволил уменьшить количество проводов с восьми до одного для передачи прерываний.

Теперь у каждого процессора была собственная система управления прерываниями. Вместо аналоговых проводов использовались цифровые сигналы, что обеспечило большую гибкость и возможность более эффективного распределения прерываний между процессорами.

#### **MSI — Message Signaled Interrupts**

С переходом на MSI количество доступных прерываний увеличилось до 256. **APIC** стал эмулироваться через MSI. Основное отличие MSI от предыдущих систем заключается в том, что теперь вместо физического провода и бита в регистре прерываний, система отправляет сообщение, которое отображается на адресах виртуальной памяти. 

Если раньше при возникновении прерывания нужно было выяснить через шину, с какого устройства оно поступило, то теперь сообщение с указанием источника прерывания передается сразу. Прерывание и взаимодействие с устройствами могут быть реализованы двумя способами:

1. **in/out** — традиционный метод взаимодействия с устройствами.
2. **mmio** — Memory-Mapped Input/Output, способ взаимодействия через отображение адресов устройств в память.

Виртуальная память содержит специальную область для конфигурации шин PSI (Peripheral Component Interconnect). Это область в 256 байт, где записываются данные о конфигурации. В случае возникновения события от внешнего устройства система обращается к этой памяти, чтобы узнать, какое устройство вызвало прерывание. После этого принимаются соответствующие меры — от чтения данных до выполнения других операций.

В системе MSI доступно 256 "посадочных мест" для работы с прерываниями, а линии прерываний можно выбирать в зависимости от их номера.

#### **MSI-X**

MSI-X представляет собой расширение MSI, увеличивая количество доступных "мест" для общения с внешними устройствами до 2048. В дополнение к шине **PSI-E** (PCI Express) MSI-X улучшает возможности работы с прерываниями и позволяет более гибко настраивать шины для связи с устройствами. Однако настройка PSI шины и конфигурация прерываний в MSI-X является сложной задачей и требует дополнительной работы по программированию и управлению.


### Способы взаимодействия с внешними устройствами

1) **in/out** — стандартный метод взаимодействия с внешними устройствами через команды ввода/вывода. Процессор отправляет команды через специальные порты.
2) **mmio** — регистры внешних устройств отображены на адреса виртуальной памяти. Команды, отправленные внешнему устройству, записываются напрямую в эту область памяти, где устройство считывает их.
3) **Захват части ОЗУ** — когда внешнее устройство занимает часть оперативной памяти. При записи в ОЗУ эти данные передаются на внешнее устройство, как если бы это был простой доступ к памяти.
4) **DMA (Direct Memory Access)** — используется для минимизации участия процессора в длительных операциях обмена данными с внешними устройствами. Идея заключается в том, что процессор только инициирует операцию, а дальнейший процесс обмена выполняется автоматически, без его участия.

Ввод и вывод можно разделить на:

- **синхронный ввод/вывод** — операция, при которой оба участника процесса (процессор и устройство) блокируются до завершения обмена данными. Весь процесс выполняется последовательно.
- **асинхронный ввод/вывод** — в этом случае ввод/вывод может происходить параллельно. Например, область данных, которая отображается на экране, хранится в ОЗУ как массив (банк). Каждое устройство имеет возможность завершить операцию, не дожидаясь завершения обмена.

![[Pasted image 20240921094301.png]]

#### DMA — Direct Memory Access

DMA позволяет внешнему устройству напрямую обмениваться данными с ОЗУ, минуя процессор, что существенно ускоряет работу с внешними устройствами. Процесс работы DMA можно разделить на несколько этапов.

1. **Стадия настройки** — этот процесс начинается при загрузке операционной системы:
    1. Устройству сообщается адрес в физической памяти (не виртуальной) и номер прерывания. Устройства могут быть различной сложности: некоторые могут работать с **low mem** (нижние 32-битные адреса памяти), а некоторые поддерживают **high mem** — память выше 2^32, вплоть до 64-битных адресов. Устройство может потребовать выделения непрерывного блока памяти, но также может работать с разрозненными участками памяти (например, 500-600 МБ шесть раз по отдельности) (РИСУНОК 11).![[Pasted image 20240921092229.png]]
    2. Отображение виртуальной памяти на физическую. Если у нас есть кусочек памяти в ОЗУ, мы должны выделить область для работы с ним. Устройство напрямую взаимодействует с физической памятью, не обращая внимания на процессор. Оно занимает часть ОЗУ для своих операций. Операционная система отображает адреса виртуальной памяти ядра на физическую область, куда устройство записывает данные. Таким образом, когда происходит команда `mov` в виртуальной памяти, она отображается в ОЗУ и автоматически передается во внешнее устройство (РИСУНОК 12).

2. **DMA обмен**:
    1. Копирование данных. Занятая область в ОЗУ теперь называется **DMA областью**. Данные, находящиеся в виртуальной памяти, копируются в эту область. В зависимости от устройства, может быть возможность настроить обмен без копирования.
    2. Через **mmio** передается команда внешнему устройству, например, на чтение определённой области ОЗУ и запись данных.
    3. Процессор продолжает работать как обычно, без участия в обмене.
    4. Прерывание сообщает о завершении операции — либо успешно, либо с ошибкой.
    5. Через **mmio** проверяется статус операции для получения результата или дальнейшей команды для записи устройства.
