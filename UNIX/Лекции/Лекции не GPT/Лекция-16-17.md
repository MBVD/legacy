
### Как строить ядро?

1. Монолитное ядро. Встречаются редко. Для того чтобы запихать в коробку аппаратную которую вы знаете. Смысл монолитного ядра если вы хотите добавить новый компонент то придется переформатировать все ядро
2. Расширяемое ядро. По сути в основном то с чем мы имеем дело. Чтобы добавить компонент, ядро необязательно целиком перекомпилировать  и можно использовать специальные утилиты `modprobe` `insmod` для подгрузки компонентов к ядру. Проблема в том что если вы разрешаете любому, кто мог сделать файл в модуль ядра и запихал его туда, в случае если в этом коде который вы всунули есть ошибки, то все ядро накроется полностью
3. Микроядро. По идее оно защищает от нежелательных ошибок кода. У нас есть микроядро которое управление памятью и там еще есть специальная внутренняя виртуальная шина для обмена сообщениями. Все компоненты ядра (управление сетью и тд) устроено кка отдельные процессоры со своим изолированным виртуальным адресным пространством. В случае с микроядром по идее, можноо уронить какую-то компоненту, но не получится целиком. 

Пример:
`gnu nurd`

### Сигналы

Что такое сигналы? Это аналог прерываний в аппаратуре но на более высоком уровне. Что у нас связано с сигналом, у нас есть такая штука как ___"очередь" сигналов___ 
1. "Очередь" сигналов
2. Сигнальная маска
3. Таблица обработчиков сигнала
Когда вы что то читаете про сигналы, очень рекомендуется почитать `man 7 signal` - там есть таблица какие сигналы вообще есть.

![[Pasted image 20240925110347.png]]

Будем обсуждать таблицу обработчиков сигнала. Сам по себе сигнал - это некое событие, некая информация событий и эта информация кладется в "очередь" сигналов.  Когда ядро обнвруживает что есть что-то в очереди сигналов, оно выполняет действие. Это жействие должно быть написано в таблицке обработчика сигналов. Какие сигналы бывают?

1. Сигналы с информацией об ошибках. 
	1. SIGBUSS
	2. SIGILL - повредился исполняемый файл и если вы пытаетесь исполнить программу для более позднего семейства процессоров
	3. SIGFPE - какую то чушь с арифметикой (необязательно с floating point)
	4. SIGSEGV - призывается если обратились туда куда не нужно
	5. SIGSYS 
	6. Эти ошибки перечислены по степени гадкости

##### Завершение процсса

Как процесс может завершиться? 
1. Можно вызвать системный вызов `-exit()`
2. "Словить" сигнал - когда на голову падает кирпич. Кирпич бывает двух видов
	1. С dump памяти
	2. Без dump памяти

###### Сигналы для завершения процесса

Как приличные люди завершают процесс? 
1. SIGTERM - шлется сигнал процессу завершить
2. SIGABRT - процесс завершается еще с dump памяти. Есть функция `abort()` которая для процесса выставляет сигнал `SIGABRT`. Вы сишную программу можете завершить тремя способами:
		1. `exit()`
		2. `return from main`
		3. `abort()` - в том месте где вы его вызвали происходит dump памяти.
3. Завершение с терминала: 
	1. SIGINT - ctrl + C 
	2. SIGQUIT - ctrl + \\ 
4. Завершение ядром
	1. SIGKILL - если он возник, если его умудрились выставить, то у процесса нет возможности защититься от этого сигнала. Приводит к полному зомбированию процесса, никакой dump не происходит. Единственный сигнал который доаствляется процессору даже в состоянии "остановлен" (остальные сигналы в данном состоянии не доставляются)

##### Остановка процесса

Какими сигналами можно остановить процесс
1. SIGSTOP - тот же эффект что и `SIGKILL`, от этой остановки нельзя спастись. 
2. SIGTSTP - возникает в UNIX, если нажать ctrl+z
3. SIGTTIN 
4. SIGTTOU
5. SIGCONT
6. SIGCHLD - в цикле должны вызвать `waitpid`

##### Взаимодействие процессов между собой
1. SIGUSR 1
2. SIGUSR 2
3. SIGRTMIN - сигналы реального времени. 
4. SIGRTMAX - сигналы реального времени

##### Прочие сигналы

SIGHUP - разрыв терминальной линии. Более-менее экзотика. 
SIGIO - (SIGPOLL)
SIGTRAP - он возникает если в том процессе который вы отлаживаете случилось какое-то событие. При этом вы с ядром зарнее договорились какие события вы будете ждать. Есть системный вызов `trap()` 
SIGALARM - сигналы про таймер
SIGVALARM - сигналы про таймер


#### Действия на сигнал

1. Завершить процесс
2. Завершить процесс с dump памяти
3. Остановить процесс
4. Восстановить работу процесса
5. Запустить пользовательский обработчик - боль для ядра, потому что когда мы запускаем поользовательский обработчик, прихллдится из ядра пекрключаться в user space и потом переключаться в ядро а затем снова в userspace в другое место. Частый вызов пользовательского обработчика тормозит. 
6. Игнорировать - эквивалентно запускаете пустую функцию реакции на сигнал. 

#### Функции для работы с сигналами

В отличии от прерываний, у сигналов нет приоритетов и более менее доставляются в порядке их появления.

###### Функции выставление сигналов
1. sigque 
2. kill
```c
kill (pit_t pid, int sig)
```
	pid>0 - 
	pid==0 - швыряться сигналом во все процессы у которых та же самая группа процессов что и процессов которые выставляют kill
	pid==-1 
	pid < -1 - идентификатор группы процессов и выставляется всем

##### Очередь сигналов ( рисунок 1)

![[Pasted image 20240925115708.png]]

Часть систенмо составляющей системного процесса. Есть некая ячейка по числу сигналов - тут в ячейках по очереди какой сигнал был первым. Первый сигнал, второй сигнал, третий сигнал, до какого-то там сигнала.  Размер массива совпадаетс  количеством сигналов. Если сигнал 2 возник первым то пишем 2, если третий возник вторым, то пишем 3, и так далее 2,3,9,24,1. Каждый новый сигнал если его нет, он добавляется в конец массива. В сигнале лежит такая штука как `struct siginfo` и каждый раз когда возникает сигнал вы переписываете ячейки. Поэтому для обычных сигналов есть проблема насчет слипания. Если вы произвели действия с SIGKILL, то на эту таблицу больше нет смысла смотреть. Есть сигнал реального времени ( SIGRTMIN ) - в нем находится глава списка из SIGINFO. Если у вас есть сигнал реального времени, то займется больше времени для обрбаотки ведь мы проходимся по списку.

#### Сигнальная маска

Она нужна как и для прерываний: для обработки какого-то сигнала, мы могли заблокировать остальные сигналы. Для этого есть функция: `SIGPROCMASK`. `sig_emptyset`, `sig_addset` и т.д.
Если где-то выставлены единички в сигнальной маске, то это означает что реакция на этот сигнал не наступает ( это не игнорирование, если вы снимите единичку, то ядро произведет реакцию)

#### Доставка сигналов

Вспоминаем картинку с клонированием (РИСУНОК 2). У нас есть кванты клонирования, и вот наш процесс. Тут происходит действия на сигналы. Вы написали такие обработчики - вы все время находитесь в обработчике. Важное следствие: сигнал доставляется не мгновенно, а отложенно(через некоторое время). Для процесса в котором выполняется поулчатеся что обработка сигнала он может застать на произвольной инструкции также как и для прерываний. `pause()`, есть функция `sigwait`, `sigwaitinfo`, 
`sigsuspend` - на время устанавливаете маску, усыпляете процесс, а вам ничего не возвращается и запускаются обработчики. Все эти функции представленные они не требуют возвращения из kernel space в user space и работаем с тем что есть. При этом если вы вызвали sigwait или sigwaitinfo то обработчик сигнала не будет запущен


#### Работа с мануалкой


![[Pasted image 20240925123938.png]]
Выставляем новый обработчик или передаем старый


![[Pasted image 20240925124007.png]]

sa_handler - обработчик старого образца
sa_sigaction - обработчик нового образца( в реальности все есть в siginfo_t)

`sigset_t sa_mask;` - sa_mask - сигнальнеая маска. На время запуска обработчика та сигнальная маска которая и так уже выставлена она меняется на эту сигнальную маску которую суете

`void (*sa_resolve)` используетсся ядром внутри. Если вы не знаете зачем оно вам то лучше туда не лезть

`int sa_flags` как вы конкретно выставляете обработчик сигнала.

Вы либо заполняете поле sa_handler либо sa_sigaction. (Изменяя один вы меняете другой)


![[Pasted image 20240925124351.png]]

Если вы настраиваете sa_handler, то вы можете выставить 
`SIG_DFL` обработчик сигнала по умолчанию
`SIG_IGN` - игнорирование(но не пустую функцию). Ваша пустая функция работа без смены user_space

![[Pasted image 20240925124539.png]]

Если указывается `SA_SIGINFO` то вы меняетесь с sa_handler в sa_sigaction

В sa_flags можно указать кучу всего:

1. SA_RESTART - если вы что то читаете из файла и сигналом были спалены ядром, то вас выкидывает с чтения. И если вы не выставите этот флаг, обратно вы туда не вернетесь![[Pasted image 20240925124633.png]]
2. Вы можете выставить обработчик сигнала так что он сработает ровно один раз, а потом сбросится на обработчик сигнала по умолчанию![[Pasted image 20240925124808.png]]

#### Программа(Классика жанра)

```c 
#include <stdio.h>

#include <signal.h>

#include <stdlib.h>

#include <unistd.h>

  

#define MAX_PUSHES 3

  

volatile unsigned int counter = 0;

  

void ctrlc_action(int sig, siginfo_t *info, void *foo) {

  

    if (counter <= MAX_PUSHES) {

        counter++;

        printf("Pushed %u from before %u exit\n", counter, MAX_PUSHES);

    }

    else {

        printf("By by\n");

        exit(0);

    }

}

  

int main () {

    struct sigaction act = {0};

    sigemptyset(&act.sa_mask);

    act.sa_flags = SA_SIGINFO | SA_RESTART;

    act.sa_sigaction = ctrlc_action;

    sigaction(SIGINT, &act, NULL);

    while(1) {

        pause();

    }
    return 200;
}
```

Сколько то там ctrl+c и завершение программы

```c
#include <stdio.h>
#include <signal.h>
#include <stdlib.h>

#define MAX_PUSHES 3
```

![[Pasted image 20240925125302.png]]

Она ничего не возвращает, поэтому единственный способ повоздействовать на программу это поменять глобальные переменные. 

```c
volatile unsigned int counter = 0;
```

volatile - запрет распространения данных на кэширование, короче запрет оптимизации размещении переменной в памяти. На все операции с ней вы будете явно обращаться в память, компилятор не станет оптимизировать. 


```c
volatile unsigned int counter = 0;

  

void ctrlc_action(int sig, siginfo_t *info, void *foo) {

  

    if (counter < MAX_PUSHES) {

        counter++;

        printf("Pushed %u from before %u exit\n", counter, MAX_PUSHES);

    }

}
```

Если ваш обработчик будет прерван другим обработчиком, то буфер printf будет в несогласованном состоянии. Например в основной программе до обработчика мы можем пользоваться printf. Мы можем завести свой буфер и пользоваться printf буферизованным образом внутри обработчика.

```c
volatile unsigned int counter = 0;

  

void ctrlc_action(int sig, siginfo_t *info, void *foo) {

  

    if (counter < MAX_PUSHES) {

        counter++;

        printf("Pushed %u from before %u exit\n", counter, MAX_PUSHES);

    }

    else {

        printf("By by\n");

        exit(0);

    }

}
```


По умолчанию когда вы выставляете обработчик сигнала, в сигнальную маску добавляется сам этот сигнал. 

```c
struct sigaction act = {0};
sigemptyset(&act.sa_mask);
```

Обработчик будет иметь два флага

```c
act.sa_flags = SA_SIGINFO | SA_RESTART;
```

Повесили нашу программу и оказались в ожидании
```c
while(1) {

        pause();

    }
```


Вывод будет таков:

![[Pasted image 20240925131050.png]]

Есть еще вот такая структура:

![[Pasted image 20240925131213.png]]


#### Программа 2 (Парадокс звездочек)

```c
#include <unistd.h>
#include <stdio.h>
#include <sys/wait.h>

int main() {

    printf("* ");

    fork();

    fork();

    wait(NULL);

    wait(NULL);
    // printf("pid = %d, ppid = %d\n", (int)getpid(), (int)getppid());
    return 0;

}
```

Способ лечения многих звездочек

fork - копирует вирт память в том числе и буфер и когда в буфере лежала звездочка, она копировалась в сыновьях

Чтобы она не лежала в сыновьях то надо использоваться `\n` чтобы буфер был хотя бы очищен. 

```c
#include <unistd.h>
#include <stdio.h>
#include <sys/wait.h>

int main() {

    printf("* ");

    fflush(stdout);

    fork();
    fork();  

    wait(NULL);
    wait(NULL);

    printf("pid = %d, ppid = %d\n", (int)getpid(), (int)getppid());
    return 0;
}
```


### Файловая система 

Файловая система в UNIX это абстракция.
1) Она иерархическая( У нее есть корень от которого все растет)
2) Есть требования на некую минимальную информацию, которую должен предоставлять драйвер для объектов файловой системы. Вот эта минимальная информация собрана в vinode, vnode
3) У одного физического объекта в файловой системе может быть несколько имён. (UNIX требует)
4) Есть операция монтирования/отмонтирования. Вот у нас есть некое дерево. Есть какой то usr, есть lib, есть root. И usr есть local. Мы можем вместо этого дерева приклеить какое-то дерево (забиваем что тут было какое то дерево и клеим какое то другое дерево) - это называется ___операцией монтирования___. У нас есть системный вызов - `mount`. Есть файл в каталоге /etc/fstab - там написано что куда монтировать. Если тут блок какого то поддерева, то это поддерево прогибается и до него никак не дойти пока есть монтированное дерево сверху от него

#### mount

1. Точка монтирования ( путь в дереве)
2. Устройство с которого монтировать ( с устройством есть некая засада: бывает разные особые файловые системы(например prog и sys) и для них устройства нет)
3. Драйвер (определяется типом файловой системы). Он содержимое устройства превращает в набор каталогов и виртуальных индексных дескрипторов. В конечном итоге драйвер обеспечивает операции чтения и записи. Он отвечает за размещение файловой системы на устройстве. 
4. Опции монтирования. 

Опции то что `mount` знает:

![[Pasted image 20240925134736.png]]


Монтировать можно в разных режимах. Есть например специальная опция: что делать с файловой системой если там случились ошибки - `remount`, если что то случается на устройстве то файловая система ремонтируется как `read-only`. Линуксовое ядро позволяет монтировать один каталог на другой ( например установка ОС: каталог prog должен быть общим с вашим экземпляром и с тем что вы ставите, чтобы  ваш пакет посмотрел не на наш prog а в его prog. Иначе будут неприятности). 

Самая важная фишка - это виртуальные индексные дескрипторы. Существуют набор типов объектов. 
1) Регулярный файл. Это некоторая интерпретируемая последовательность байт
2) Каталог - в любом каталоге где он существует, всегда представлены две записи - две точки - это ссылка выше на иерархию. У самого высшего будет ссылка на самого себя
	1) `..` - выше по иерархии
	2) `.`  - ссылка на самого себя. `./a.out` - для этого и нужна точка
3) Символическая ссылка. Это специальный объект и специальный файл коорый хранит в себе путь  файловой системы и ядро когда взаимодействует с файлом понимает это какая `redirect` на то что он указывает.  
4) файл устройства. Это специальным образом оформленная дырка к драйверам устройств. 
5) FIFO - межпроцессорное взаимодействие
6) сокеты ( семейство PF_UNIX) - межпроцессорное взаимодействие


#### Файлы устройств

Тип
1. c - символьный
2. b -блочный

1. Мажорный номер - номер шины
2. Минорный номер - поля номере устройства в машине

С каждым файлом устройства ассоциируется некоторая таблица - число системных вызовов. Что лежит внутри этой таблицы? Лежит указатель функции ядра который должен реализовать...

![[Pasted image 20240925140808.png]]

