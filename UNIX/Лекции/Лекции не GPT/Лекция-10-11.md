
### Управление памятью

Мы как бы закончили аппаратную часть, там потом встретиться еще, переходим к внутреннему устройству ядра. 

#### Инвертированная таблица страниц

Если прямая таблица была построена из виртуального адреса, то это инвертированная строится из физического адреса. Как она выглядит (РИСУНОК 1)
Её размер - число физических страниц. Что здесь лежит: условно свободно/занято, виртуальный адрес, ссылка в виртуальной памяти ядра на каталоги. Почему нужна ссылка? Иерархия таблицы страниц может быть много по каждому процессу. В Машечкине сказано что тут находится pid процессор ( возможно не совсем корректно). Смысл в том чтобы добраться до конкретной иерархии память, конкретного процесса, ссылка должна быть в виртуальной памяти ядра, эта информация нужна ядру. Получается следующее:
Вот таблица, она на все физические страницы. Когда виртуальные страницы отображаются на физические, то в ОЗУ возникает физические страницы. Сама ОЗУ разбита на такие страницы (РИСУНОК 2). Вот это вот физическая страница. Если у нас есть в виртуальной памяти большие страницы, то в ОЗУ у нас будет некие объединения страниц меньшего размера. Здесь будут отдельные записи которые будут одинаковыми. (не уверен). У нас получается что часть ОЗУ занята, часть свободна. (РИСУНОК 3). При этом мы знаем, что инвертированная таблица страниц кому конкретно принадлежит соответствующий участок. Давайте обсудим какие запросы могут быть на выделении памяти:

0. Не запрос. Это память для размещения кода ядра и принципиальных данных и таблиц. (сам BIOS размещает все это в памяти. В тот момент когда ядро запускается и создает инвертированную таблицу страниц, часть полей в ней помечена как занятые, не зависят ни от чего, никто не пытался вызывать функции выделения памяти) (ядро - это некоторая программа которую скомпилировали в исполнительный файл и вот эта штука должна быть размещена В ОЗУ и размещает ядро загрузчик. Когда ядро себя обнаруживает то уже существует для него инвертированную таблицу страниц и он занимает себе место в ней.) 
1. Запрос непрерывного пространства в ОЗУ. Для обеспечения этого явления, что делать ядру? Она работает с помощью функции `kmalloc` и в пару с ней `kfree` 
2. Запрос непрерывного в виртуальной памяти участка. Эта память должна быть подряд в виртуальной памяти, но необязательно в физической.  `vmalloc` и `vfree`

Давайте про первый способ представления:

#### Запрос непрерывного участка. 

>[!Note] 
>buddy system - отдельное событие, дополнительная конвертированная таблица страниц.

В этом месте происходят странные вещи. Создаётся три зоны: low, high, ... ; и на low и high создаётся специальная штука под названием: `buddy system`, которая создается при загрузке ядра. Ядро заранее резервирует некий диапазон непрерывный участок в ОЗУ - как правильно не очень большой (кажется 2^10 страниц). У нас есть 3 таких `buddy system` и мы захватываем три участка. Все эти три памяти станут DMA диапазонами. Для DMA требуется чтобы он был в конкретном месте. Причем, третий диапазон может быть во всей памяти целиком (потенциально). (РИСУНОК 4) Здесь вот ноль здесь вот M, соответственно тут адрес < 2^16. Мы берем. резервируем некий кусок (физические страницы  в этом куске помечены как занятые и `buddy system` освобождает нам ситуацию от попытки занять кусок памяти `malloc`, который уже занят ядром). Потом идёт medium диапазон до high, тут тоже выделен непрерывный кусок `buddy system` (в этом случае `high buddy`). Самым дефицитным является buddy нижнего уровня и если ваша железяка умеет работать с medium диапазоном, то нужно всегда его тут пихать, потому что вдруг он не умеет работать с нижним диапазоном.  

`kmalloc` - высокоуровневая функция пользующаяся другими функциями. Одной из функций является `get_free_pages`. И как `buddy system` устроен
(РИСУНОК 5) Buddy system необходимо быть степенью двойки. Один блок - это 1 страница физическая. 
#####  Бинарная куча и построение дерева в buddy system (Алгоритм buddy system)

Есть такая штука как бинарная куча ( алгоритм). Для бинарной кучи гарантируется что все массивы которые правее всегда меньше чем те которые находится ближе к началу. Вот эти `buddy system` для нее строится бинарная куча и строится специфично: строится дерево. Создаётся массив всевозможных комбинаций физических страниц. Идея такая: мы строим дерево, сперва у нас некий кусок размером 2^N, из этого куска у нас есть два поддерева и они помечаются как свободные, сам кусок помечается как свободный. Говорим следующее: "хочу 5 страниц", что при этом происходит. Здесь этот диапазон это 16 страниц. Какая-то часть этого диапазона ( например младшая) у нас занята, делаем такую же запись на 8 страниц слева и 8 страниц справа (левый диапазон занятый, правый диапазон свободный). Каждая вот такая штука из 8 страниц, снова делим пополам, у нас появляется снова два поддерева на каждом поддереве (одно поддерево помечается как свободное, другое как занятное). Выполняем ту же операцию и оба поддерева будут свободными (это листья в дереве) и отдаётся адрес последнего занятого поддерева. Мы делим блок в памяти пополам, снова пополам и возвращает адрес этого разделенного блока через функцию `get_free_pages`. Мы выделяем память кратную странице, нам она нужна часто но не всегда. Иногда может быть память который занимает больше чем 1 страницу или меньше чем 1 страницу

##### Slab - алгоритм. Slab system

Идея: Создается некий список этих slaboв. Slabы объединяют в себе наборы записей одинакового размера, но которые не кратны размеру страницы. Поэтому может быть неиспользуемые дырки неподходящие для слаба и неподходящие страницы. В каком смысле slab. Если посмотреть в коридор лежит плитки, и лежит большая плита лежащая на маленьких плитках. Размеры маленьких плиток это slab, а одна большая плита - это страница. У него есть размер, есть страница, в страницу помещаются плитки. В тот момент когда мы выделяем память, мы запрашиваем, если это необходимо, страницу в ядре при помощи `get_free_pages` и начинаем заполнять плитки внутри этой страницы. Сама это страница помнит количество свободных slabов.  Есть несколько таких плит. Их объединяет, что они все одинакового размера. Когда выделяете память, то если свободно плитка номер 1, то вам не нужна плитка номер 2. 
`kmalloc(10 байт, имя slab)` ну грубо говоря говорите для чего это вам надо. kmalloc ищет вам среди всех плиток подходящую плитку и возвращает адрес этого slab. Если не нашлась страница с подходящим slabом, то мы берем следующую страницу через `get_free_pages` и находим там подходящий slab. Если вы сделали `kmalloc`, вот это вот всё приклеивается(если резервируется страница) к вашей новой памяти. Как правило оно приклеивается к памяти ядра, но можно и приклеить к памяти программы. 

##### vmalloc

Он бежит по инвертиррваннаым таблицам страниц находит незанятые блоки выдает по одной странице пока не будет нужный размер. При этом ему указывается адресное пространство( каталог страниц), он в нем модифицирует записи нынешней страницы, те страницы которые идут подряд они принадлежат соответствующему процессору. 

### Неприятности

Какие могут быть неприятности? Неприятность может быть одна - памяти нет физически. Вы вызвали `kmalloc` и `kmalloc` говорит что памяти нет. Что должно делать ядро? В этой ситуации возможно два сценария:

1)  Запускается специальный код под которого память заранее выделена, который соответственно сообщает о проблеме и устраивает Kernel Panic. 
2) Запускается oom killer. Посколько проблема нужна ядру, а памяти нет, то он смотрит на список программ, выбирает ту которую не жалко (ту которая не повлияет на жизнь системы). Если эта программа запущена от root, то ее тоже убивать нельзя. Если идентификатор пользователя меньше тысячи, то это тоже что-то системное и нельзя убивать. Потом происходит магия с размерами памяти программы, кажется он стремится убить ту программу которая занимает меньше памяти ( не уверен), менее всего активна или более всего активна

Вопрос: Какое действие в коде ядра может непосредственно привести к запуску «oom killer».
Ответ: после  вызова malloc и malloc вернул ноль - запускается oom killer.

Запускается overcomit. Кажется `vmalloc`  можно разрешить захватывать страницы ***ленивым*** образом. Вот у вас виртуальное адресное пространство(от 0 до 2^n), вот тут ваши данные и среди ваших данных есть куча. Malloc, calloc, free. Что мы можем сделать? Мы можем сдвинуть границу кучи в стороне виртуальных адресов с помощью системного вызова ядра называемого `brk`. Когда вы задвигаете кучу вниз вы расширяете простраство виртуальной пмяти кокоторрой можно обращаться. Практика покзаывает что расширяя пространство вниз, вы с боольшей вероятностью обращаться к ней не будете. В системе есть такая штука `overcommit` и `overcommit ratio` - она поможет выделить памяти, больше чем физической. brk внутри ядра вызывает функцию malloc. Либо у вас malloc удался, либо malloc не удался, тогда программа упала, но на другие программы не повлияло и ядро работает. Вы можете позволить `overcommit ratio` взять больше памяти чем физически возможных и тогда вызывается oom killer. 


Информация о buddy лежит в /proc/buddy и /proc/slabinfo. Как устроен логическим образом виртуальная память

### Виртуальная память процессов и ядра

Значит user space. Значит виртуальная память Kernel space включает в себя вирт память user space. Страница или несколько страниц близки к вирт адресу ноль. Принципиально не отображены ни на какой ОЗУ. Зачем это нужно? Чтобы у вас `segmentation fault` случался: NULL. В самом ядре на этих адресах может что то находиться. 

Дальше идет другой кусок памяти ( потенциально большой) - это память ядра. В этот кусок памяти нельзя что-то писать. Из некоторых соображений ( обычно усложняет само ядро), вот этой памяти может не быть для userа и таким образом у ядра своя независимая виртуальная память. Одна та же страница в вирт памяти процессора в вирт памяти ядра отображается в разных местах виртуальной памяти.  Удаление этой части памяти ядра от userа сделано для того, чтобы косвенным образом не узнать что там вообще лежит. Смысл этого спектра мы образаемся к некоторму адресу к какому то `addr` с каким то значением `c` и при попытке прочиттаь эту ячейу, нам говрртя: "записать нельзя" с разной скоростью. И таким образом можно будет нелегальным способом получиьь информацию о ядре

Дальше у нас идет код программный. Дальше идет дата, идет бсс и в конце даты и перед началом бсс находится заголовок кучи. Дальше идет куча - куча это память которую вы можете `malloc` и `free`. С кучей есть еще одна фишка и может идти не сразу вплотную к bss, то есть после bss может идти дырка. Эта куча идет вниз. 
Перед кучей или после кучи может идти "Область отображений файлов на памяти" (mmap).
Как правило вот эти страницы после кучи не отображены в виртуальной памяти и эта дырка от начала кучи до конца вирт памяти - она гигантская. Вот это место где кончается куча, она помечается штукой под названием brk и может двигаться brk вверх - уменьшения адресов(освобождение памяти для ядра) и brk вниз - увеличения адресов.(захватывание памяти от ядра для самого себя). Когда вы сделаете malloc вам дадут эти адреса. Malloc впринципе может вместо того чтобы изменить brk, какой-то участок памяти выделить не при помощи изменения brk а с помощью mmap - это тоже способ выделения памяти. Преимущество такого подхода в том что можно подвинуть стек, чтобы увеличить стек. 
Внутренняя память ядра устроена примерно также
(РИСУНОК)
Вначале идет mmio, потом код ядра, потом данные ядра и стек ядра который растет с конца-вверх. Дальше вниз будут идти фактические данные пользовательских процессов 

Нарисую ОЗУ. Вирт память ядра. Вот какие-то значит страницы ядра, вот они отображены в каких-то местах оперативной памяти. Красным у нас будет программа 1 и оно отображено на какие то кусочки оперативной памяти. Если что то нужно сотворить с красной фигней из пространства ядра, то у нас файл ассоциируется. И еще одна программа - программа 2. На памяти ядра может быть отображено только то с чем вы взаимодействуете. В ядре какой-то синий кусок можем отобразить. Может происходить наложения в ОЗУ: когда два процесса работают в одном участке (условно сине красный диапазон, а там сине-желтый) Случилось страашное

### SWAPPING(СВОППИНГ)

Чистая страница - которая синхронизирована с HDD
грязная страница - которая не синхронизирована с HDD

Когда память можем сохранять на внешнем устройстве. Внешнее устройство может быть ОЗУ, а ОЗУ как кэш для этого устройства. Как правило, размер своппинга превышает размер ОЗУ. В норме жизни смысл такой что каждый адрес тоесть щас да вот у нас есть своппинг и каждый адрес который у нас сипотзовался разными программами  жто типа жетский диск (РИСУНОК11) Теперь если сделкать так то у нас значит есть жесткий диск и он тоже разбит на страницы. В отличии от ОЗУ - это долгосрочная память, которая сохранится при выключении, но важно тут что она более медленная и черт знает где она. Идея какая: вот эти страницы которые есть в вирт памяти мы может отобразить не на ОЗУ, а на жесткий диск. С ядром не все атк просто там есть страницы которые нельзя выкачивать. Часть страниц ядра например вот жжто оно может быть отображено вот туда. Мы можем отобразить на жесткий диск. Фишка такая, у нас может быть вот такое отображение. 

Жесткий диск(HDD), ОП, ВИРТ
Все ситуации СВОППИНГА:
1) виртуальная память не отображена на оперативной памяти и есть на HDD. Мы лезем в оперативную память находим свободный диапазон или подходящего кандидата среди чистых страниц и инициируем операцию чтения жесткого диска при нахождении кандидата. (так как он срочный это может быть выполнено не страничным демоном а чем нибудь другим)
2) Виртуальная память отображена на оперативной памяти и чистая. Ничего не делаем и все отлично (страничный демон счетчики отображения пересчитывает) 
3) Виртуальная память отображена на оперативной памяти и грязная, то есть у нас еще отображение на жесткий диск. Тогда инициируем операцию обеспечения чистоты этой страницы(операция DMA) по истечению какого-то времени. 
4) Виртуальная память отображена на оперативной памяти и нет на HDD. Это может говорить о двух вещах: ( такая страница по умолчанию грязная!!!!). (демон тут не работает)
	1) Либо это страница ядра и недолжна отображаться на HDD ( например страница с хешами и паролями). Тогда ситуация нормальная и она никак не исправляется
	2) Либо это вообще новая страница, ей нужно задать отображение на жестком дискке и потихоньку синхронизировать. 

Всеми этими вещами занимается страничный демон. Он работает по таймеру через определенное количество времени. Проходится по всему что лежит в ОЗУ и производит необходимые действия по синхронизации.
	
### Алгоритм выбора страницы для замещения

У нас на каждую страницу может быть 4 счетчика. Страничный демон запускается по таймеру и мы видим что страница была прочитана и мы берем "сколько не читали" и выставляем в ноль. 
1) Число чтений. Когда бит доступа выставлен в 1 а бит грязности 0
2) Число записей. Когда 
3) Сколько не читали
4) сколько не писали

Стратегии:
1) механизм FIFO - не факт что самое менее использованное страница не станет популярным.
2) стратегия LRU - Last Recently Used. 
3) Стратегий NRU 
4) Алгоритм часов. 