
### Уровни привилегий

Где он написан? Написан в нескольких местах: сегменты, страницы, дескрипторное прерывание, регистры флагов. В регистре флагов написан текущий уровень привилегий и программа поменять не может. К попытке обратиться к сегменту или странице проверяется текущий уровень привилегий и если уровень привилегий меньше или равен уровню привилегий сегмента или страницы, то разрешается, а в дескрипторе прерываний который написан уровень привилегий устанавливается уровень который есть в регистре флагов.

CPL (у регистра флагов)

### Прерывания

Прерывания нужны для реакции на ситуацию. Смысл в прерывании в запуске стороннего кода для обработки ситуации. Сторонний код называется обработчиком прерываний. У прерывания могут быть двух видов:

1. внутренняя - те которые генерируются самими схемами процессора
2. внешняя - от внешних устройств

Внутренние прерывания делятся на прерывания и на исключения. Механизм обработки одинаков, отличаются тем что исключения могут что то куда то складывать и отправлять (адрес где случился segmentation fault в какой-то контрольный регистр). 
#### Обработка прерываний:

У нас есть регистр прерываний, регистр маски прерываний(может и не присутствовать)(в intel в регистре флагов есть поле, где можно запретить прерывание), регистр прерываний(вектор прерываний). Еще есть таблицы дескрипторов прерываний.( в intel называется idt, регистры называются idtr) - это минимум того, что необходимо для работы с прерываниями.
Есть еще полезные штуки:
1. tss - сегмент ( tss регистры) - это тоже в Intel (есть и аналогичные штуки в других архитектурах). 

(Рисунок) Что происходит. Жила была программе. Вот её instruction pointer куда-то себе указывает на следующую инструкцию, а ее нынешняя инструкция сейчас работает. Ситуация: сама эта инструкция может являться причиной прерывания, если это так, то она не выполняется(обкатывается) и процессор занимается обработкой прерываний. Вторая ситуация: это инструкция не являлась причиной прерываний, она завершается и запускается обработчик прерываний(мы переходим на обработку прерываний). 
Обработка прерываний бывает двух видов:

1. Короткие(близкие) прерывания. Не предполагает подключение куда-то еще. Оно выглядит как некий переход на некую функцию. На короткие прерывания маскирование прерываний не происходит. У нас есть стек, в макушку стека складываются регистры(в том числе регистр флагов и instruction pointer)(рисунок1). Все прерывания не пронумерованы. Мы обращаемся по нужной строчке, забираем оттуда указатель на новый instruction pointer (который написан на idt, в частности написан новый rip мы переходим на этот rip, стек остался тот же, его выполняем)(стек используется тот же, но меняется rip, код вообще в другом месте). Этот код выполняется: там еще тонкость какие регистры сохраняются и какие нет: это зависит от того что написано в строчке с idt( минимально че сохраняется это пара точек(Ip, Flags) должен все запушить и запопить, как процедуры но похуже ) Когда обработчик отработал он вызывает инструкцию iret(возврат из прерывания). Если это было короткое прерывание, то что было всунуто в стека из стека восстанавливается. Если вам нужно перейти в другой стек, то нужно самим этом позаботится
2. Длинные(далекие) прерывания. Длинный предполагает более кардинальные изменения - они заключатся в том что вы вообще переключаетесь на другой стек и происходит это аппаратно. Тогда вам нужно адрес вершины стека кладется в начало нового и этот адрес найти. В description(рисунок 2 - таблица idt) написано несколько вещей. Во первых, адрес функции обработчика и новый сегмент кода на который нужно подключиться. Нам нужно выставить ss, cs, ds и эта тройка благополучно лежат в вектор-строчке idt (также rsp, rip). Вместо всего этого может лежать номер tss в tss-сегменте. Мы переключаемся на tss и там лежит некоторая запись. В 32 битной системе лежат все регистры которые нужно восстановить. В 64 битной с rip, там лежат три указателя на стек, сегмент кода такой же. На стеке по всем уровням привилегий лежат все соответствующие указатели на стеки. Конкретный механизм зависит от архитектуры(в Intel все важно зависит от версии процессора). 
В intel:

1. Длинные и далекие без tss
2. Длинные и далекие с tss

1. У нас есть вектор прерываний - он же регистр прерываний. (РИСУНОК 3). Битовая хрень (256 битный - зависит от архитектуры). Явным образом скрыт от программиста. 
2. Есть регистр маски прерываний. Столько же бит сколько в регистре прерываний.(РИСУНОК 4), если в регистре прерываний стоит единичка и в регистре маски прерываний там же стоит единичка, это означает что реакция не происходит. Если в той же позиции на номере прерываний стоит единичка - обработчик запускаться не будет. 
3. nmi - немаскированные регистры прерываний - если это случилось обработчик на нем запустится в любом случае. 

Все прерывания, которые есть, они имеют приоритеты. 
Как правило процессор как только он входит.

Последовательност прерываний
1. аппаратная стадия. 
	1. Маскирование всех прерываний
	2. Сохранения точки исполнения.
	3. Передача управления на обработчик (выставление новой точки которая будет исполняться) 
2. программная стадия
	1. Сохраняем остальные регистры которые будем менять (вообще все)(не очень хорошо если программа в каком то регистре имеет счетчик, произошло прерывание и регистр изменяется. Должны сохраниться вообще все регистры)
	2. Произвести срочные действия (если они есть). Смысл срочных действий в том, что обработка других прерываний запрещена, вас никто не прервет. 
	3. Снятие маски прерываний. Как только вы сняли маску прерываний, ваш обработчик прерываний может прервать другие прерывания
	4. Несрочные/долгосрочные действия. Есть такая штука как прерывания по таймеру - при прерывании по таймеру вы заходите в массив и какие то счетчики увеличиваются. 
	5. Восстановление регистров 
	6. Вызов iret. Переключение с одной программы на другую. Когда вызываем прерывание мы находимся в режиме ядра мы  делать задачи и вызовом iret можем оказаться в другой программе ( по умолчанию оказываемся в той же программе). В tss сегменте в соответствующей tss находится точка возврата в программу ( а также ядро знает точку возврата). В idt есть соответствующий уровень привилегий для работы с ядром. 
	## 7. Запускается вновь аппаратная часть после iret которая непрерывается.

Проблема в том: с обработкой прерываний есть несколько проблем: (РИСУНОК 5)
1. Исчерпание стека. Из-за того что возникает вложенная штука на очередное прерывание stack overflow. 
2. Ошибочное маскирование прерываний. Вы что то замаскировали, обработчик поработал вышел а размаскировать забыл. 
3. Связана со (2): склеивание нескольких событий в одно. В общем случае, если случилось прерывание вы не можете знать сколько раз оно случилось. Со склеиванием можно бороться тем, чтобы обработать прерывания как можно быстрее. 
4. Возврат не туда. Случайно перепутали номер tss сегмента. 

### Таймер(часы)

##### Аппаратные таймеры

В железяке есть таймеры. В часах  есть несколько времен:
1. Момент включения. Тикает в астрономическом времени. Работает на строго определенной частоте, не в зависимости от тактовой частоты процессора
2. Отсчёт числа тактов с момента включения. Этот таймер или счетчик имеет свойство переполняться.
3. Внешние часы: астрономическая время. Плохая разрешающая способность. Есть отдельная плата для хорошей, но даже так есть плохая синхронизация времени. Протокол ptp(time protocol) - есть некий таймер с хорошей разрешающей способностью, которую стоит подключить в сетевую карту. По умолчанию, его нельзя использовать например для просмотра стадий ядерного взрыва. Вот для этих медленных часов в мат плате есть батарейки. 

##### Прерывание по таймеру

У нас есть таймер с высоко разрешающей способностью и когда он делает +1 то происходит прерывание. Разрешающая способность считается в наносек. В соответсвии с прерыванием по таймеру, в ядре есть свой набор таймеров высокого разрешения: в сущности, два числа.
1) Значение таймера
2) На каком значении реагировать. 
Идея в том что  обработчик прерывания проходится по массиву пар этих двух чисел того что есть в двух числах и обновляет соответствующий счетчик и если значения совпали, то он выставляет другое прерывание, на которое должен среагировать обработчик прерывания которые делает действия с определенным таймером. 
Таймер получается - прерывание внутри ядра для себя самого. Чем реже может реагировать таймер тем больше мы можем их сделать. 

### NMI - прерывание

Может быть несколько. Помимо nmi есть watchdog(таймер)
У нас естт некоторый регистр, который увеличивается все время и в этот регистр: сначала ноль, пропускающая способность 1024, когда случается 1024 происходит немаскированное прерывание. watchdog - счетчик который накапливается и его нужно сбросить. Есть два таких watchdog:
1. На материнской плате - нужен для защиты от аппаратных зависаний. Если вы не сбросили его в 0, то он активируется и перемыкает разъемы питания. 
2. Внутри ядра - для отладки самого ядра. Если ядро зависло, то есть немаскированное прерывание, которое показывает синий экран смерти.
Если что то намудрили с прерываниями, то вся система пойдет в разнос. Таких собак больше чем одна.


### Внешние прерывания

В начале был ic ( interrupt controller). 
Потом был pic  - pci
Потом был opic - pci
Потом все кончилось и случился MSI - PCI-EXPRESS
потом MSI-X

#### IC

(РИСУНОК 6) Слоты для внешнего устройства. Где то тут процессор и рядом с ним IC. С одной стороны он был аналоговым устройством, с другой он был цифровым. От каждого устройства и каждой позиции - выходило несколько физических проводов. Если посмотреть на плату которую туда вставляли - это была ISA шина. Если посмотреть на плату этой шины, то она выглядела вот так (РИСУНОК 7): какие-то там контакты и еще какая-то штука, так называемые джемперы. Компьютеры были большие а периферий мало. Эти линии прерываний было аж 8. Каждый тип устройства замыкал свой провод. Автоматически перенаправлялся на определенные биты регистра прерывания. Если этот проврлок выставлен ( штук 10 ) и 11 номер прерывания находится на внешнем устройстве на IC. Дальше происходило еще несколько действий, этот IC становился чем более сложным ( из одного в две микросхемы). Эти две микросхемы уехали внутрь процессора. IC стал PIC: необходимость в джамперах отпала, потому-что на IC нужно было сказать какой провод теперь какому прерыванию соответствует в регистр прерываний. Микросхемы стали каскадными (РИСУНОК 8). Объединение прерываний - 8 выходов как было так и осталось - внутри прерываний мы вместе со смещением столько же 8 штук и выставляем, но теперь одному прерыванию начинает соответствовать много устройств. Возникает легкая неприятность, что несмотря на то что происходит по прерыванию, нужно посмотреть что это за устройство такое и замедляет процесс. Во времена PIC появляется отдельный провод по которому мы можем эту микросхему запрограммировать. Можем сказать замкнутой вот этой ноге и этой ноге какой прерывание сопоставить из вектора прерываний. 

#### OPIC

OPIC предполагает наличие нескольких процессоров: система выглядит так (РИСУНОК 9)
Внутри него лежит свой LPIC и есть свой внешний APIC. Вот эти провода перестали быть аналоговыми, из платы тянуть один провод, а не восемь. Процессоров много. Кружочки означают внешнее устройство. Вентили из которых делаются процессор стали мельче, следующий этап развития стал MSI


#### MSI

Прерываний было 256. APIC эмулируется MSI-ом. PIC совместим с IC. В чем отличие: Если у нас тут возникало прерывание, то у нас выставлялся бит прерывания, дальше мы должны были лезть в шину, а с какого устройства пришло наше прерывание. Теперь вместе с прерыванием выдаётся сообщение, которое лежит в адресах, отображаемых на виртуальной памяти. Вспоминаем как мы можем взаимодействовать с внешним устройтствами. 
1 способ: in/out
2 способ: mmio(memory map input output)
Соответсвтенно у вас возникло прерывание и к контроллеру psi шин обратииться: от кого? Как это выглядит? (РИСУНОК 10)
Вот наша виртуальная память. Ближе к вирт памяти находится кусок 256 байт: это конфигурация шин PSI. Там много чего можно написать. Там показывается адрес неопределенного размера, место для общения с psi. Когда у вас происходит какое-то событие от устройства вы должны прочитать это место с psi контроллера и выяснить от какого внешнего устрйоства у вас произошло событеи, дальешв завимости мот события ямы можем совершить обмеен или предпринять дейтсвия. В случае MSI у нас есть 256 посадочных мест.  Линии прерывания можно выбирать по степени двойки

#### MSI-X

Предполагает что у вас таких мест где можно поговорить с внешним устройством 2048 (PSI-E + MSI-X). Настройка psi шины не тривиальное задание. 


### Способы взаимодействия с внешними устройствами

1) in/out
2) mmio - регистры внешнего устройства наложены на адреса виртуальной памяти.  Написание команд внешним устройству выглядит 
3) Когда оборудование захватывает часть ОЗУ. Когда мы пишем в ОЗУ оно каким то образом отображается на внешнее устройство. 
4) DMA - для того чтобы избегать участия процессора в длительных операциях обмена с внешним устройством. Идеалогически устроено так что мы сперва в синхронном режиме.
Ввод и вывод бывает:
1) синхронный - операция обмена, на время этой операции, оба устройства блокируется пока не дойдет передача. 
2) асинхронный - область который отображаем на экране лежит как массив в ОЗУ - это называется неким банком.  Каждому из участников обмена разрешается разблокировать раньше чем обмен будет совершен


#### DMA

У нас есть процессор, ОЗУ, внешние устройства (РИСУНОК 10). Внещнее устройство сввязано с ЦПУ и ОЗУ. 

1. Стадия настройки. При загрузке ОС. 
	1. Мы устройству сообщаем адрес в физической памяти ( не виртуальной)  и номер прерывания. Устройства могут быть разной степени умности. Это называется low mem. Дальше идет high mem - до 2^32 и дальше вся остальная память. Устройство может понимать 64битные адреса а может не понимать. Устройство может потребовать 10 мб памяти подряд. А можно сказать - да ничего страшного, 500-600мб 6 раз. (РИС 11). 
	2. Отображение виртуальной на физическую. Вот у нас кусочек на ОЗУ (РИСУНОК 12), нам нужно выделить место на котором изображен этот кусочек. Устройства знает про устройство ОЗУ и у него есть собственный ход вот сюда и он ничего не знает про ЦПУ. Устройство занимает кусочек ОЗУ(будем с ним там разговаривать). Ядро теперь должен сделать отображение адреса с виртуальной на физическую. Сами для себя отобразили кусок виртуальной памяти ( скорее всего память ядра) на место ОЗУ, теперь когда `mov` делаем в виртуальной памяти, то он отображается в ОЗУ и передается во внешнее устройство. 
2. DMA обмен 
	1. Копируем. Занятая область в ОЗУ нами теперь называется DMA - данные где то лежат в вирт памяти. Копируем данные в DMA область. Гипотетически можно поступить так: взять и включить механизм настройки, если устройство позволяет, то перемещаем. 
	2. Через mmio сообщаете команду устройства. Например, что нужно устройству прочитать кусок ОЗУ и записать
	3. Обычный ход жизни процессора. 
	4. Прерывание. Либо обмен закончен успешно,
	5. Через mmio смотрим статус операции. Для записи устройства