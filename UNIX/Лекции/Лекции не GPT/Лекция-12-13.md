### Процессы

Что такое процессы? Процесс - это вещь которая обладает ресурс. Процесс должен на чём-то исполняться. Кроме ресурсов времени процесса, он захватывает ресурсы памяти. Он может потреблять виртуальные ресурсы (количество файлов, которых он открыл, количество семафоров, разделяемых памятей, высокоуровневых абстракций ОС). С другой стороны, процесс - это абстракция представляемая ОС и конкретный экземпляр вообще говоря нужно где-то хранить и хранится она в такой штуке как "Таблица процессов". Скорее всего это не таблица, а массив или список. У каждого процесса есть свой идентификатор `pid`. Этот `pid` является ключом к таблицу процессов. `pid` - это некоторое число, но не является номером строчки таблицы. Нас интересует конкретная запись в таблицу. Есть такое понятие как "контекст процесса".

##### Контекст процесса

У него есть три составляющие:

1) Аппаратная составляющая - те физические ресурсы( регистры процессора например), которые процесс потребляет в текущий момент. 
2) Пользовательская составляющая - по сути вся часть процесса которая может выполняться в user space, все его переменные, данные, все что лежит в swap оно лежит, что можно сделать там `mov` или `call`. 
3) Системная составляющая: все что нужно ядру, чтобы поддерживать абстракцию процесса. Внутренние ядреные буфера ассоциированные с операциями ввода/вывода и так далее. Процесс может понакрывать позакрывать кучу штук: кучу файлов, кучу таблицу открытых файлов. Все это системная составляющая. 

##### Системная составляющая

1. Разные идентификаторы. 
	1. pid - уникальный идентификатор процесса. 
	2. ppid - идентификатор процесса, который назначен данным процессом быть родителем. (Может быть настоящим родителем или опекуном). Связана с деятельностью initа. Дочерние процессы можно найти по полю родительского процесса
	3. uid - идентификатор пользователя, которому принадлежит процесс. В моменте старта системы, процесс принадлежит пользователю root и имеет идентификатор 0
	4. gid - идентификатор групп пользователей.
	5. euid -  Эффективный идентификатор пользователя ( имеет право или не имеет ). Понимать что процесс имеет право делать. uid и gid может быть наставлены в 1000, а euid и egid выставлены в 0.
	6. egid - Эффективный идентификатор групп пользователей ( имеют право или не имеют ). Понимать что процесс имеет право делать. uid и gid может быть наставлены в 1000, а euid и egid выставлены в 0. 
	7. pgid - идентификатор процессной группы
	8. sid - идентификатор сессии.


##### pid, ppid, sid (Дерево, сироты, убийства, убийства сирот)

В тот момент когда мы создаём процесс, кто является отцом первого процесса? ppid может написан нолик ( ядро является отцом initа). Дальше когда мы создаем новые процессы такое дерево. (РИСУНОК 1) Процессор с идентификатором 1 называется init. например 10, 20, 40, у них ppid будет по единичке. Их идентификатор сессии будет тоже по единицам. sid имеет то же значение что и pid. Грубо говоря с созданием init обращается в единицу и процесс может поменять, но менять может строго на свой pid. Дальше мы наплодили процессов: 62, 48, 51, 33, 175. У них в качестве ppid будет 10, а sid у них будет все один. В другой ветке ppid будет 20, и sid 1. В другой ветке будет ppid 40 и sid будет 1. Вот мы еще наделали кучу процессов: 150, 160, 170. Ppid медленно исчерпываются. (если систему долго не перегружали, то это не верно). Здесь у нас ppid 62 и sid 1. Начнем гадости делать. перерисовываем стрелки. Внезапно случилось страшное и процесс 62 убили, а эти процессы остались. 150, 160, 170 становятся сиротами, поэтому отцом их становится init. (РИС 1.2) Картина вот такая. Это не настоящая картина, такое в системе нельзя сейчас найти. Почему? Потому что init это особая программа, ее задача не просто существовать, а основная задача развернуть набор остальных программ(сервисов. демонов) чтобы они работали и функционировали. Поэтому наследники init будут иметь другую сессию. Поэтому сессии у потомков 10 будет 10, 10, 10. (РИС 1.3) Очередная задача init: собирать инфу о том как завершались процессы. С одной стороны, init это не надо, с другой стороны, если это не делать, то таблица процессов будет переполняться, таким образом, этим действием мы очищаем таблицу. Есть ограничения на таблицу процессов, который пользователь может создать. Что значить процесс создать - это означает создать запись в таблице процессов. Если вы пишете программу как идиот, то собирать информацию о том как закончились процессы вы не собираетесь и после этого не получится создать новые процессы в том числе процесс, удаляющий другие процессы. Опекун добрый и ласковый, пока существует лидер сессии. Лидер сессии - это процесс, у которого pid совпадает с идентификатором сессии. ( Новую сессию можно создать только из своего pid). В случае если этот процесс перестал существовать (РИС 1.4) init перестает быть добрым и ласковым, он начинает отстрел процессов которые не имеют лидера сессии. (48, 61, 150, 160, 170). И не факт что init отстреливает, а отстреливает само ядро. Отсюда важное следствие: что такое демон? Демон - это процесс, который является лидером сессии. Он должен работать сам по себе. Как правило когда вы заходите систему - то для вас создается новая сессия. И если грохнуть shell или графическую систему, то вы, грохнув этого лидера сессии, то у вас посыпаются все вкладки, приложения и т.д.


##### Как узнать свой pid?

`getpid`, `getppid`
```c
pidt getpid()
pidt getppid()
```

##### uid, gid, euid, egid 

1. Повышение прав. Ваш идентификатор пользователя становится идентификатором root. `su`, `sudo`. Он работает через файловую систему и систему прав (suидные биты)
2. Понижение прав. Когда меняете права с эффективного идентификатора 0 на любое отличное от нуля идентификатор. В отличие от WIndows где все живут под пользователем АДМИН, в Linux(UNIX) это не так. Если вы сидите под пользователем root ( там можно сидеть), то вы можете себя считать идиотом. Понижение прав может сделать любой пользователь. `getuid`, `getgid`, `geteuid`, `getegid`, `seteuid`, `setgid`, `setuid`, `setegid`. Командами `set` могут  пользоваться пользователи с идентификатором 0. 
3. Параллельный перенос прав. В Linux запрещен. uid, gid, euig, egid меняете произвольное значение на другое произвольное значение. Он возможен только одним способом (Рисунок 2): вы повышаете права до пользователя root (  процедура повышения прав ) и потом понижаем права ( процедура понижения прав). 

##### pgid

Идентификатор процессной группы нужен чтобы процессы объединять в группы. Если вы пишите shell допустим, то набор процессов, которые вы запускаете в рамках одной инструкцции с вертикальными палками ввода и вывода принеадлежнат одной группе. Это удобно потому что всю группу процессом можно грохнуть. Это штука обладает сторонним эффектом: "есть терминал(группа) и на нем написана группа на терминале. Если процессная группа совпадает с группой на терминале и по моему еще с pid, то процесс имеет право читать что-то с терминала, то есть пользователя с клавиатуры. В остальных случаях он будет получать сигнал SIGTTIN, SIGTTOUT где процесс не завершается, но останавливается."


##### Linux-специфика

Есть понятие - пространство имён и пространство ресурсов (cgroup). Пространство имён из определенной группы процесса делает новый init и получается что внутри своя собственная иерархия. Это нужно, чтобы запускать кучу программ в изолированном пространстве. namespace id. 

##### Текущий каталог

`getcwd` 
`setcwd` (возможно `chdir`) 

##### Корневой каталог

`chroot` 

##### Состояние процесса

Вот он появился и его состояние: "готов к выполнению" потом может попасть в "выполняется" дальше он может попасть в состояние "зомби" и после этого он окончательным образом вытирается из таблицы процессов (`wait`).  (РИСУНОК 3)
{"Готов к выполнению", "Выполняется", "Зомби", "Остановлен", "Заблокировать", `SIGKILL`, `wait`, "системные вызовы IO"}

##### Поле nice

Есть системный  вызов `nice` и `renice`. Приоритет процесса. 

1. Статическая составляющая.
2. Динамическая составляющая. 

##### Статическая составляющая

1 штраф: штраф за не realtime. Есть какие то специальные процессы, которые должен получить процессы и его оттуда никто не должен вышибать 
2 штраф: штраф за userspace. Если вы не демон, то вам штраф.
3 штраф: штраф за не `euid == 0`. Если вы обычная программа обычного пользователя и чтобы вы не задавили системные программы, вам выдают штраф.

(РИСУНОК 4) Все это пространство циферками отдалить, вот эти штрафы realtime, ядро(kernel), root. По умолчанию он выставляет штрафы по умолчанию и nice заметно выше приоритет минимальной границы который можно выставить. Сделано это для того чтобы пользователь мог выделить нужные ему процессы больше чем другие  < root

##### Динамическая составляющая

От того как недавно вы выполняли процесс. Если он недавно, то выставляется большой штраф в процесс и штраф со временем убывает. 

#####  Планирование процессов

Существуют 3 стратегии планирования процессов:

1) Система реального времени - системой реального времени означает что перключаться из одного процесса на другой \это плохое явление и переключение обусловлено директивными интервалами. Елси у нас возник процесс то у нас есть директивный иентревел в предел которого он может выполнятсьяв. У него есть tstart и tfinish. По достижению tfinish он отправляется в очередь "готов к выполнению". Сам такой процесс должен гарантировать свое содержательное действие за директивный интервал ( он  выполнит гарантированно что-то за этот интервал) а потом переключаемся на другой процесс. 
2) Система разделения времени. У нас есть куча программ, отдавая кусок ресурса процессора на выполнение. У нас через определенный промежуток мы выбиваем из процессора обратно к "готов к выполнению" и переключаемся на другую программу.
3) Пакетный режим - переключение между процессами настолько велики, что их вообще не стоит менять, переключать.

##### Ограничения

Есть довольно странная штука под названием capabilities - это ограничения на множество системных вызовов которая может выполнять программа. 

##### Создание процесса

Двумя системными вызовами: `fork` - системный вызов для девочек.
`clone` - системный вызов для мальчиков. Что делает `fork`? Создает новый процесс, но как? (РИСУНОК 5) Вот произвольный процесс, у него есть виртуальная память. Секция text благополучно отображена на ОЗУ через страничный механизм. Есть секция data и она тоже отображена на ОЗУ. Еще у нас есть стек, он тоже отображен на ОЗУ. Где-то здесь взяли и дошли до fork. fork копирует память отцовского процесса в сыновний. Он копирует данные и стек. Он возвращает pid сыновнего процесса. А в сыновнем fork возвращает ноль. Мы создаем виртуальную память нового сыновнего процесса. У нас есть text который отображает на ровно такие же адреса что и в родительском процессе. Память отцовского процесса копируется в сыновний но не полностью. Поскольку стек с большей вероятностью будет изменен, поэтому его верхушка сразу перенесена. Сыновний процесс себя обнаруживает в том же месте что и отцовский, из fork он выглядит так словно он выпал из системного вызова и отец и сын. Оба процесса видят у себя одинаковую виртуальную память ( и они должны ) с одними и теми же значениями. Но fork сына вернет 0, а fork отца вернет pid сына. Есть поле ppid - с каким-то значением. 

Есть еще один способ создания процесса называется `vfork`. Пользоваться не нужно - он устаревший. Идея какая: немного сэкономить. 

