
# Замена кода программ

1. Частично. Системный вызов `mmap`. В
2. Полностью. Системный вызов `execve`. Вирт память опустошается той программы к которой мы выполнили `execve`

##### mmap

Есть волшебная вирт память процесса, у нас есть ОП и в случае с mmap у нас еще есть память на диске(файл). Рядом отрисую файл внутри диска. В нем есть начало и есть конец. У нас есть два разных отображения мы при помощи mmap мы содержимое этого файла отображаем на виртуальную память. Мы делаем это по тому же механзиму что и ыцфззштп nj tcnm cnfdbv cjjndtncbdt flhtcfv bdhn gfvznb flhtcf  какие то там части в файле отсюда возникает серьезные ограничения, Смещение по которому мы делаем отображение относительно начала файла должна быть кратна страница. Мы делим файл на страницы. Соответствующие страницы отображаем на оперативную память и вдальнейшем отображаем на какой то диапазон виртуальной памяти ( размер диапазона - это размер отображения). Файл может быть отображен не целиком, а только вырез. Две стрелочки которыми можем управлять - 1) отображение вирт памяти на ОП.(задать что будет написано на таблице страниц отображаемого) 2) Отображение диска на ОП.
(1) (2) - отдельные параметры системного вызова mmap. 

Параметры mmap:
1. Адрес (в качестве адреса можно написать null - ядро сам должен искать место, типа `malloc` )
2. Протоколы: влияет на (1) стрелку (отображение вирт памяти на ОП): там может быть `PROT_READ` `PROT_WRITE` `PROT_EXEC`(право на исполнение). Секция текст она будет отображена с `PROT_EXEC`. Также еще есть `PROC_NONE` - память выделили, а с ней ниче нельзя делать. `PROT` должен быть согласован с тем как файл у вас открыт.  
3. На стрелку (2) влияет набор опций(как можно отображать): `MAP_SHARED`, `MAP_PRIVATE`, `MAP_ANONYMOUS`

Ленивое отображение: copy and write. Реальное отображение происходит когда вы напрямую обращаетесь к виртуальному адресу
Не ленивое отображение: 

Можно ставить опцию синхронизации: все что вы написали в вирт памяти или ОП тут же должно синхронизироваться в файл. Большая часть этого относится к `map_shared`

`map_shared` - те изменение которые вносятся в ОП ЗАТЕМ ДОЛЖНЫ БЫТЬ ЗАПИСАНЫ НА ЖЕСТКИЙ ДИСК. 

Парная функция к mmap - `munmap`. Больше параметров чем адрес которым мы mmap, там еще указываетсяс размер. 
Есть функция `msync` - принудительно синхронизировать с файлом данные которые мы работали в ОП. 
Если вы грохнули отображение, вместе с грохнутым отображением надо вызывать `msync`

Если указать `MAP_PRIVATE`. Это означает что вы отображаете вызов в файл только на чтение. 

`MAP_ANONYMOUS` - не подразумевает наличие какого то файла. Он управляет отображением ОП-ВИРТ, не включая файл. Это нужно для того чтобы устраивать разделяемую память между создаваемыми процессами, когда вы делаете `fork` отображение ОП-ВИРТ наследуется. За исключением случаев с вызовом `execve`. 

При помощи mmap можно творить грязь: это отображение можно сделать на нулевой виртуальный адрес. 

3) режим отображения
4) размер отображения
5) смещение в файле. Оно должно быть кратно размеру страницы
6) Файловый дескриптор. При `map_anonymous` файловый дескриптор становится -1.

Что будет если размер отображения больше чем размер файла? Segmentation fault
Пользуемся `ftrancate` для расширения размера файла. 

##### execve

Функция от трех аргументов. Назначение: запуск новой программы в теле существующего процесса. В Linux нельзя сделать программу с новым кодом: сперва должны `fork` или `clone`, а затем сделать замену тела процесса. 

argv - название программы( он обязан заканчиваться нулевым указателем),
env - набор строк такого вида "имя_переменной = значение". Список таких переменных заканчивается \0. 
Переменная env: PATH = список каталогов для поиска исполняемого файла. 
PATH - /bin/sbin/usr/bin: /usr/sbini/home/vasd/bin
Когда ищете файл который исполнять, проходим по каталогам. 
Переменная env: HOME - домашний каталог пользователя
Переменная env: LD_LIBRARY_PATH - список каталогов для поиска динамически загружаемых библиотек ( Ld - линковщик )
Переменная env: UID -
И ТАК ДАЛЕЕ

```c
int execve(const char *path_to_executable, char** argv, char** env)
// returning код ошибки(int)
```

Что делает execve с вирт памятью? Оно все ее заменяет(опустошает)
Где там лежат аргументы которые мы передаем и что мы исполняем? Начинается с 

```nasm
_start:
```

Вы вызвали `execve` - чужой родился и ему удалось разорвать программу. Он найдет метку start и начнет оттуда исполнение ( в том числе подгружаемые библиотек). 

Где взять аргументы и сколько их? Через стековый вызов мы сохраняем аргументы `execve`. 

##### env

`getenv`, `setenv`. У main три аргумента

```c
void main(int argc, char **argv, char** env);
char ** environ - "не стандартизировано"
```

Лучше всего пользоваться `getenv`, `setenv` 


##### exec

работа suid bits
1) на владельца
2) на группу
в норме предполгается что если поставлен suid bits.