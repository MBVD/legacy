
### Файлы устройства

В ядре у нас лежит набор таблиц по количеству шин. В каждой таблице есть одна запись, в которой перечислены точки входа ассоциированные с системным вызовом

Одна сплошная таблица: тут номер таблицы, тут некий номер системного вызова ассоциирован с позицией в таблице, внутри лежит указатель на функцию ядра. Если вызываете системный вызов с соответствующего файлового устройства, то у вас вызывается функция которая является точкой входа в драйвере. Не все устройства не являются реальными ( есть понятие виртуальный терминал и драйвер обеспечивающий виртуальный терминал). И есть вообще виртуальное устройство имеющее отношение к устройству, а есть виртуальные устройства вообще не имеющее отношение к устройству. Среди этих шин есть специальная шина - шина для устройств, которая никак не связан с устройствами, но связана с устройствами связанные с ядром. Какие это устройства:

1) Устройства `/dev/zero` - некий файл, с которого можно читать безграничное число нулей
2) Устройство `/dev/null` - это черная дыра. Тут можно что угодно писать и оно там исчезнет. Поток сознания программы `./prog 2 > /dev/null` ошибки не будут сыпаться вам в терминал, а сыпаться в `/dev/null` которая поглощает. ( Всё что не хотите видеть - отправляйте в `/dev/null`) (2 - номер потока ошибок)
3) Устройство `/dev/random` - оттуда можно получить некоторое количество истинно случайных чисел. Ядро это делает удивительным способом. 
4) Устройство `/dev/urandom` - получаем псевдослучайные числа. Он работает быстрее нежели `/dev/random`
5) Устройство `/dev/tty` - это терминал. 
6) Устройство `/dev/tty12...` - Это виртуальные терминалы: их глубокий смысл в том что вы можете там написать по отдельности и каждый из этих терминалов ассоциируется с настоящим терминалом только если вы сделаете его активным
7) Устройство `/dev/pts` - эти виртуальные терминалы создаются самими программами через специальные системные вызовы: shell, console, 

>[!tip] 
>ssh(виртуальные терминал) - программа предоставляемая shell на определенной машине. Клавиатура и экранчик - это локально, но все что вы вбиваете на клавиатуре отправляется в отдаленную систему и там она отработает

#### Жесткие диски

Именование сильно отличается от ОС. (scasi, serial ata, ...)
Linux: `/dev/sda, /dev/sdb, ...` 
Если вы подключаете флешку, то она также будет называться `sda, sdb` потому что это тоже scasi устройство
Раньше оно называлось `hda`, `hdb` - когда шина была IDE
`/dev/mmcblk01...` - что-то в этом духе, в общем отвратительно называется. 

#### Floppy Disk

`/dev/fd`

#### DVD, blue-ray

Всё оптическое и всё крутящееся

`/dev/cdrom`

#### Блочное/символьное

`/dev/sda1` - если `sda` это блочное устройство, то `sda1`, `sda2`- это символьное устройство

#### disk-by-uuid

`/dev/disk-by-uuid` - нынешние ОС предоставляют некоторый уникальный номер устройства и по этому уникальному номеру его можно запоминать. Диск может называться `sda1` и `disk-by-uuid....`.  Различия в названиях между разными ОС будет в разных форматах. Если посмотреть в файл `fstap` диски будут не по именам, а по uuidам. Это для того, чтобы когда вы перемещаете его по порядку, то у него поменяется `sda` и соответствующий номер.

#### dd - утилита

` dd if = файл of = файл(файл устройства)` - вы возьмете файл с if и побайтово перезапишете в файл of. Этот файл побайтово будет перемещен в файл устройства. Если файл с диска побайтово перемещаете в файл устройства, то возникнут проблемы (какие проблемы?). 

#### /dev/audio

У вас прилеплено к аудиокарте вашей системы, опять же все не так просто, потому-что ваша звуковая карта может поддерживать медиа разных форматов или не может поддерживать медиа разных форматов.

#### /dev/video

Внешние устройства (веб-камера например). 

#### vnode, vfs

Ядро загрузки приклеивает корневую файловую систему. Вот здесь у нас есть набор индексных дескрипторов ( с каждым узлом дерева ассоциирован индексный дескриптор ) . 
Индексный дескриптор бывает настоящий и настоящий никому не нужен. Бывает виртуальный `vnode` ( у ядра есть требования о том что находится в этом `vnode`). Файловая система когда она примонтирована в ядро, она имеет свое название и называется `vfs` (Virtual File System) - само понятие системы того как она выглядит в ядре и то как она выглядит из программ. Что требуется:

1. Тип объекта - одно из полей виртуального файлового дескриптора. ( В зависимости от типа, поля могут отличаться. )
2. указатель на `inode` (индексный дескриптор) - указатель на настоящий файловый дескриптор, который описывает этот объект. Нормальная программа не пользуется индексным дескриптором, потому что он нужен драйверу, чтобы программе предоставить данные. Этот `inode` - это связь между файловым объектом с драйвером файловой системы.
3. Счётчик ссылок на данный объект. Это список альтернативных имен. Если посмотреть как устроен каталог в UNIX, он должен быть устроен следующим образом: в каталоге у нас на произвольную штуку должны написаны две вещи: имя объекта и номер `vnode`. Что такое имя объекта? В UNIX имеет строгий размер ( не может быть больше 256 байт). `vnode` он один и у него может существовать несколько имен ( т.е. несколько ссылок). Вы можете создавать файл или удалять файл. Когда вы удаляете файл вы на самом деле удаляете только одно имя этого объекта и реальный объект может быть удален в случае если все имена удалены. Представим, что у нас есть каталог `a` и в нём каталог `b` и в нем есть `c` `d`. Сколько имен имеет каталог `a`? Есть каталог b в таком случае каталог `a` будет доступен через b с помощью `..` Мы при помощи системного вызова `link` можем принудительно одному из объектов сделать еще одно имя, но есть ограничения. В этой ситуации(рисунок с примонтированным деревом) мы можем делать имена только в примантированной области. 
4. Владелец объекта (`uid_t`)
5. Группа объекта (`uid_t`)
6. Права доступа - стандартные UNIX права доступа - это 12 бит. Это вот такое целое число: тут младшие биты, а тут старшие. Написанная буква означает выставленную единичку в этом месте. Например: rwx - 3 бита на младшие, rwx - 3 бита на группу объекта и 3 rwx на пользовательские. У каждого есть `euid` `egid`. Проверяем младшие биты, если с владельцем совпадает, то идем на старшие биты. Если права доступа есть, то операция разрешается и выполняется, если права доступа нет, то операция отклоняется. Вы на старшие биты можете выставить нули, а в младшие - единицы ( вы тем самым ограничиваете возможность использования). Если `euid` не совпал, то мы смотрим на `egid` и `uid_t группы`, если они не совпали, то мы лезем в массив групп, к которому может принадлежать пользователи и соответственно если есть совпадение, то мы снова спрашиваем: можем ли это сделать или нельзя. 
7. 3 метки времени (time spec):
	1. Метка изменения метаинформации об объекте
	2. Метка последнего доступа к объекту
	3. Метка последнего изменения

>[!tip]
>Имя файла в файле не хранится

8. xattr 
0. Размер файла

#### Системная утилита - stat
 
```c
stat(const char* path, struct stat *st) - "выдаст инфу на то что указывает символическая ссылка"
```

```c
lstat(const char* path, struct stat *st) - "выдаст инфу о символической ссылке"
```

```c
fstat()
```

#### Действия с файлами

1. Для удаления: `unlink` - манипуляция как объектами файловой системы
2. `link`
3. `rename`? `move` 
4. `chmod`- сменить права доступа
5. `chown` - сменить владельца
6. `creat` ~ `open` - open имеет функциональность creat
7. Системные вызовы для работы с файлом, не связанные с внутренностями: 
	1. `open`
	2. `close`
	3. `flock`
8. Манипуляция с внутренностями файла 
	1. `lseek` - перемещение курсора
	2. `fcntl` - позволяет управлять то тем как вы открыли файл и блокировать участки в файле для того чтобы если вы там читаете пишете много процессов, чтобы не дать какому-то процессу зайти. 
	3. `ioctl` - настройки функционирования. Взаимодействияя с файлом описывающиеся операциями read/write
	4. `mmap` - 
	5. `read`
	6. `write`
	7. `sync` - Они блокируют процесс(все процессы) пока данные находящиеся в ядре не окажутся в физическом устройстве
	8. `fsync` - можно всунуть файловый дескриптор. 

### Структура Каталогов

###### Корень

`/etc` - настройки программ
`/proc` - человеко-понимаемый интерфейс с ядром
`/sys` - программно понимаемый интерфейс с ядром
`/dev` - файлы устройства
`/bin`  наиболее важные программы
`/sbin` - наиболее важные системные утилиты
`/lib` - наиболее важные библиотеки
`/lib/modules` - лежат модули ядра
`/boot` - всё про загрузку. 
`/root` - домашний каталог пользователя root. 
`/var` - содержит в себе так называемую базу данных. Данные, которые меняются по ходу времени и нужны для функционирования системных программ. 
`/usr` - каталог с программами условно не изменяемые. 
 `/opt` - не структурированное программное обеспечение. Авторы intel c++ компилятора не ходят следовать принципам каталогов ( библиотеки в usr/lib) а кидают все в /upt
 `/home` - домашний каталог пользователей
 `/srv` - сервисы предоставляемые данной машиной
 `/tmp` - временные файлы. Когда init начинает запускать процессы, то tmp потихоньку начинает загружаться. 

#### Внутренняя структура var

`/run` - раньше он был в `/var/run` (pid файлы)
`/var/log` `syslog` `bootlog` `errog.log`
`/var/lib`
`/var/tmp` -
`/var/cache` - в нем лежат временные файлы (пакеты которые скачали через интернет перед тем как его поставить)
`/var/crush`

#### Внутренняя структура usr

`/usr/lib` - библиотеки
`/usr/bin`
`/usr/sbin` - системные утилиты
`/usr/lib32`
`/usr/lib64`
`usr/include`
`/usr/share`
`usr/local`
`/usr/src` - он предназначен для хранения исходников ядра, хранение и компиляция модулей. 
`/usr/local` 


### Работа с файлами. 

```c
int open (...)
```

Таблица открытых файлов.

Когда вы открываете файл на записи/чтения, у вас возникает сразу же две новые записи: одна записи создается в таблице открытых файлов процесса и вторая в табьлтце открытых файлов ядра
Чтот лежит втаблтице открыых файлов ядра - курсор в файле и некий буфер ядра на io с этим файлом. Через операции с этим файлом у нас происходит обращение к драйверу файловой системы либо к драйверу к устройству. С этой табличкой файлов процесса можно сделать всякие манипуляции: например `fork`. После `fork` у нас создается новая таблица открытых файлов. Мы можем открыть тот же самый файл на записи. Синхронизация обращений к диску - это ваше личное дело как программиста, если вы два раза открыли файл и что-то туда записываете - то там может оказаться что угодно.
Когда вы пишите файл, вы пишите нккоторые блоки файла в файловой системе и в принципе  файлы которые пишется дают. Стрелочкой которая связана с синхронизацией с внешним устройством связана sync и fsync/ 
Есть еще два системных вызова: `int dup(int oldfd);`, ` int dup2(int oldfd, int newfd);` 
Вот эту таблицу открытых файлов ядра можно посмотреть с помощью `lsof`

#### open

```c
int open(const char* PATH, int flags, mode_t mod)
```
Если файл существует, то mode_t игнорируется
В flags вы обязаны что то одно: `O_RDONLY`, `O_RDWR`, `O_WRONLY`
`O_CREAT`, `O_TRUNC`, `O_APPEND`, 
`O_EXCL` - используется с `O_CREAT`
`O_CLOEXEC`, 
`O_SYNC` - запрещает буферизацию на уровне kernel space. 
`O_LARGEFILE` - актуалбно для 32 битных систем. Курсорный файл должен быть 64 битным 
`O_DIRECTORY` - это каталог
`O_ASYNC` - функции `aread`, `awrite` 
`O_NONBLOCK` - вы пытаетесь сделать write, а места для write нет. ИЛи сделать reead а в буфере ничего нет, тогда указав `O_NONBLOCK` вернет вам на эти функции -1

#### read and write

read and write - возвращает ssize_t

```c
ssize_t read(int fd, void buf[.count], size_t count);
0
-1
errno
EINTR
```