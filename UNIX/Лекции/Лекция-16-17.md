
### Как строить ядро?


#### 1. Монолитное ядро

Монолитное ядро включает в себя все основные функции операционной системы, такие как управление процессами, памятью, драйверы устройств и файловую систему, в одном исполняемом файле. 

- **Преимущества**:
  - Высокая производительность благодаря минимальным накладным расходам на взаимодействие между компонентами.
  - Надёжность в условиях стабильного кода, так как все части ядра тесно интегрированы друг с другом.
  
- **Недостатки**:
  - Малейшая ошибка в любой части ядра приводит к краху всей системы.
  - Для добавления или изменения компонентов требуется перекомпиляция всего ядра. Это усложняет обновления и добавление новых функций.

Используется, когда необходимо создать специализированную систему с известным аппаратным обеспечением и заранее предсказуемыми требованиями. Примером монолитного ядра является классическое ядро UNIX.

#### 2. Расширяемое (модульное) ядро

Расширяемое ядро позволяет динамически загружать и выгружать модули (например, драйверы устройств) без необходимости перекомпиляции всего ядра. 

- **Преимущества**:
  - Гибкость: новые модули могут добавляться и удаляться во время работы системы без перезагрузки.
  - Эффективное управление ресурсами, так как загружаются только необходимые компоненты.

- **Недостатки**:
  - Повышенные риски безопасности: если некорректный или вредоносный модуль будет загружен, он может привести к сбою или компрометации системы.
  - Ошибки в модулях могут привести к краху всего ядра, так как они выполняются с привилегиями ядра.

Примеры утилит для работы с модулями ядра:
- `modprobe`: загружает модули в ядро и их зависимости.
- `insmod`: загружает указанный модуль в ядро.
- `rmmod`: удаляет модуль из ядра.

Эти инструменты позволяют управлять модулями ядра и адаптировать систему под текущие задачи без необходимости перезагрузки.

#### 3. Микроядро

Микроядро минимизирует количество кода, работающего в привилегированном режиме. Оно включает в себя только самые необходимые функции: управление памятью, управление процессами и межпроцессное взаимодействие. Остальные компоненты, такие как файловая система или сетевые протоколы, реализуются как пользовательские процессы, взаимодействующие через сообщения.

- **Преимущества**:
  - Повышенная устойчивость системы: сбой одного компонента не приводит к краху всего ядра.
  - Упрощённое тестирование и отладка компонентов, так как они работают в пользовательском режиме и могут перезапускаться независимо от ядра.

- **Недостатки**:
  - Более высокие накладные расходы на взаимодействие между компонентами из-за использования межпроцессного взаимодействия.
  - Сложность проектирования и разработки из-за необходимости реализации многих механизмов, таких как передачи сообщений и управление памятью.

Примером микроядра является ядро GNU Hurd, которое разработано как альтернатива ядру Linux и использует микроядерный подход для разделения функций системы на независимые компоненты.

### Пример микроядра: GNU Hurd

GNU Hurd — это операционная система, основанная на концепции микроядерной архитектуры. Она использует микроядро Mach для обеспечения базовых функций управления памятью и процессов, а все остальные службы реализованы как отдельные серверы, работающие в пользовательском пространстве. Это позволяет системе оставаться устойчивой даже при сбоях отдельных компонентов, но требует более сложного механизма взаимодействия между ними.


### Сигналы

Сигналы в UNIX-подобных операционных системах можно представить как высокоуровневый аналог аппаратных прерываний. Они используются для асинхронного взаимодействия между процессами или для информирования процесса о различных событиях, таких как ошибки или запросы завершения.

Каждый сигнал представляет собой событие, которое может быть послано процессу для уведомления о каком-то состоянии или требовании выполнить определённое действие. Основные компоненты работы с сигналами включают:

1. **Очередь сигналов** — структура, в которой хранятся ожидающие сигналы. Если процесс не готов сразу обработать сигнал, он помещается в очередь и будет обработан позже.
2. **Сигнальная маска** — набор битов, указывающий, какие сигналы должны быть заблокированы (не обработаны) в данный момент.
3. **Таблица обработчиков сигналов** — структура, в которой содержатся действия, которые необходимо выполнить при получении определённых сигналов.

Рекомендуется ознакомиться с документацией по сигналам (`man 7 signal`), где представлена полная таблица доступных сигналов и их назначение.

#### Основные виды сигналов

Сигналы можно классифицировать по нескольким группам, в зависимости от их назначения и контекста использования.

![[Pasted image 20240925110347.png]]

##### 1. Сигналы ошибок

Эти сигналы указывают на различные ошибки в работе программы:

- `SIGBUS` — ошибка шины, некорректный доступ к памяти.
- `SIGILL` — недопустимая инструкция, может возникнуть при попытке выполнения команды, не поддерживаемой на данном процессоре или при повреждённом исполняемом файле.
- `SIGFPE` — ошибка в арифметических операциях, таких как деление на ноль или переполнение.
- `SIGSEGV` — нарушение защиты памяти, попытка доступа к несуществующему или запрещённому участку памяти.
- `SIGSYS` — ошибка при выполнении системного вызова.

Эти сигналы упорядочены по степени их серьёзности, от менее опасных к более критическим.

##### 2. Завершение процесса

Процесс может завершиться либо по своей инициативе, либо в результате получения сигнала:

1. **Прямое завершение процесса**:
   - Вызов системного вызова `exit()` или возврат из функции `main()`.

2. **Завершение по сигналу**:
   - Сигналы завершения могут поступать от других процессов или системы:
     - `SIGTERM` — мягкий запрос завершения, процесс может его игнорировать.
     - `SIGABRT` — сигнал аборта процесса с генерацией дампа памяти. Отправляется функцией `abort()`.
     - `SIGINT` — сигнал прерывания с терминала, обычно отправляется при нажатии `Ctrl+C`.
     - `SIGQUIT` — сигнал, аналогичный `SIGINT`, но с генерацией дампа памяти (`Ctrl+\`).
     - `SIGKILL` — принудительное завершение процесса, от него невозможно защититься. Этот сигнал не может быть перехвачен или проигнорирован.

##### 3. Остановка процесса

Эти сигналы временно приостанавливают выполнение процесса:

- `SIGSTOP` — немедленная остановка процесса, не может быть перехвачена или проигнорирована.
- `SIGTSTP` — сигнал остановки от терминала (`Ctrl+Z`).
- `SIGTTIN` и `SIGTTOU` — сигналы, посылаемые фоновым процессам при попытке чтения или записи в терминал.
- `SIGCONT` — возобновление выполнения приостановленного процесса.
- `SIGCHLD` — сигнал, который посылается родительскому процессу при изменении состояния дочернего процесса (например, завершение или остановка).

##### 4. Взаимодействие между процессами

Некоторые сигналы предназначены для обмена данными между процессами:

- `SIGUSR1` и `SIGUSR2` — пользовательские сигналы, которые могут быть использованы для любых нужд.
- `SIGRTMIN` и `SIGRTMAX` — сигналы реального времени, используемые для более точного и приоритетного взаимодействия.

##### 5. Прочие сигналы

- `SIGHUP` — сигнал разрыва связи с терминалом. Обычно используется для перезапуска процессов при изменении конфигурации.
- `SIGIO` (`SIGPOLL`) — сигнал асинхронного ввода-вывода.
- `SIGTRAP` — сигнал отладки, вызывается при срабатывании точки останова или других отладочных событий.
- `SIGALRM` — сигнал таймера, обычно используется для ограничения времени выполнения операций.
- `SIGVTALRM` — сигнал виртуального таймера, который считает только время, затраченное на выполнение процесса.

### Действия на сигнал

Сигналы в операционной системе могут вызывать различные действия в зависимости от настроек и состояния процесса. Рассмотрим основные возможные действия:

1. **Завершение процесса** — процесс сразу завершается, и ядро освобождает все его ресурсы.
2. **Завершение процесса с дампом памяти** — помимо завершения, создаётся дамп памяти процесса, который можно использовать для отладки (например, при `SIGABRT`).
3. **Остановка процесса** — процесс приостанавливает выполнение и переходит в состояние ожидания (например, `SIGSTOP`).
4. **Возобновление процесса** — приостановленный процесс продолжает выполнение с того места, где он был остановлен (например, `SIGCONT`).
5. **Запуск пользовательского обработчика** — процесс выполняет заранее определённый пользователем обработчик сигнала. Это вызывает дополнительную нагрузку на ядро, так как происходит переключение между режимом ядра и пользовательским режимом (user space). Частые вызовы пользовательских обработчиков могут значительно снизить производительность.
6. **Игнорирование сигнала** — процесс никак не реагирует на сигнал, что эквивалентно запуску пустого обработчика. Некоторые сигналы, например `SIGKILL` и `SIGSTOP`, невозможно игнорировать.

### Функции для работы с сигналами

Сигналы обрабатываются в порядке их поступления, так как приоритетов у них нет. Основные функции для управления сигналами:

#### Отправка сигналов

1. **`sigqueue`** — функция для отправки сигналов с дополнительной информацией.
2. **`kill`** — функция для отправки сигнала процессу или группе процессов:

```c
int kill(pid_t pid, int sig);
```

- `pid > 0` — сигнал отправляется процессу с указанным идентификатором `pid`.
- `pid == 0` — сигнал посылается всем процессам в текущей группе процессов.
- `pid == -1` — сигнал отправляется всем процессам, к которым у отправителя есть доступ.
- `pid < -1` — сигнал отправляется всем процессам в группе с идентификатором `-pid`.

#### Очередь сигналов

![[Pasted image 20240925115708.png]]

Очередь сигналов — это часть системных структур процесса, представляющая собой массив, в котором каждый сигнал добавляется в порядке поступления. Размер массива соответствует количеству сигналов. Если сигнал поступает первым, записывается его номер, если вторым — номер второго и так далее (например, 2, 3, 9, 24, 1). Для каждого сигнала хранится информация в структуре `struct siginfo`.

При работе с обычными сигналами возникает проблема "слипания", когда при частом возникновении одного и того же сигнала он не будет добавляться в очередь несколько раз. Для сигналов реального времени (`SIGRTMIN` и другие) такая проблема отсутствует, так как они обрабатываются со специальной очередью, что может замедлить их обработку.

#### Сигнальная маска

Сигнальная маска используется для блокировки обработки определённых сигналов. Основные функции для работы с маской:

- `sigprocmask` — установка маски сигналов.
- `sigemptyset` — очистка маски (все сигналы будут разблокированы).
- `sigaddset` — добавление сигнала в маску.

Если сигнал заблокирован в маске, его обработка будет отложена до тех пор, пока сигнал не будет разблокирован (снятие блокировки). Это не означает, что сигнал игнорируется; после снятия блокировки ядро обработает все отложенные сигналы.

### Доставка сигналов

Сигналы доставляются процессу не мгновенно, а через некоторое время после их возникновения. В процессе выполнения программы это может происходить на любой инструкции, как и в случае с аппаратными прерываниями. Важные функции для управления доставкой сигналов:

- **`pause()`** — приостанавливает выполнение процесса до получения сигнала.
- **`sigwait()`** — ожидает появления сигнала, блокируя указанные в маске сигналы.
- **`sigwaitinfo()`** — аналог `sigwait`, но возвращает дополнительную информацию о сигнале.
- **`sigsuspend()`** — временно устанавливает сигнальную маску и приостанавливает выполнение до получения сигнала.

Эти функции позволяют эффективно обрабатывать сигналы, не вызывая повторного переключения из режима ядра в режим пользователя. Если во время ожидания с использованием `sigwait` или `sigwaitinfo` поступит сигнал, обработчик сигнала не будет вызван автоматически.

### Работа с мануалом по `sigaction`

![[Pasted image 20240925123938.png]]

Структура `struct sigaction` используется для задания поведения процесса при получении определённого сигнала. Рассмотрим подробнее её поля и их назначение:

![[Pasted image 20240925124007.png]]

- **`void (*sa_handler)(int);`** — указатель на функцию-обработчик сигнала старого образца. Эта функция принимает номер сигнала как аргумент и не имеет доступа к дополнительной информации о сигнале.

- **`void (*sa_sigaction)(int, siginfo_t *, void *);`** — указатель на функцию-обработчик нового образца. В дополнение к номеру сигнала, эта функция получает структуру `siginfo_t` (содержащую подробную информацию о сигнале) и указатель на контекст выполнения. Это позволяет реализовать более гибкую и детализированную обработку сигналов.

- **`sigset_t sa_mask;`** — сигнальная маска. На время выполнения обработчика сигнала текущая сигнальная маска процесса заменяется на `sa_mask`. Это позволяет заблокировать определённые сигналы на время выполнения обработчика, чтобы избежать их наложения.

- **`int sa_flags;`** — флаги, которые определяют поведение обработчика сигнала. Основные флаги:
  - `SA_RESTART` — перезапуск прерванных системных вызовов.
  - `SA_NOCLDSTOP` — игнорирование сигнала `SIGCHLD`, когда дочерний процесс приостанавливается.
  - `SA_SIGINFO` — использование `sa_sigaction` вместо `sa_handler` для обработки сигнала.

- **`void (*sa_restorer)(void);`** — это поле зарезервировано для использования ядром и служит для восстановления контекста после обработки сигнала. Оно редко используется в пользовательском коде. Если вы не уверены в необходимости изменения этого поля, лучше оставить его по умолчанию.

### Особенности использования `sigaction`

При настройке обработчика сигнала необходимо заполнить только одно из полей `sa_handler` или `sa_sigaction`. Если вы используете `sa_sigaction`, обязательно установите флаг `SA_SIGINFO` в поле `sa_flags`, чтобы ядро знало, какой обработчик использовать. Заполнение одного поля автоматически аннулирует значение другого, так что они не должны использоваться одновременно.

### Настройка поля `sa_handler` в структуре `sigaction`

Поле `sa_handler` задаёт действие, которое будет выполнено при получении сигнала. Возможные значения:

![[Pasted image 20240925124351.png]]

1. **`SIG_DFL`** — выполнение стандартного действия, определённого для данного сигнала. Обычно это завершение процесса, игнорирование сигнала или генерация дампа памяти.
  
2. **`SIG_IGN`** — игнорирование сигнала. Это не просто вызов пустой функции: сигналы будут проигнорированы полностью, без выполнения какой-либо логики.

3. **Указатель на пользовательскую функцию** — обработчик сигнала, который принимает в качестве аргумента номер сигнала. Используется для выполнения пользовательского кода при получении сигнала.

![[Pasted image 20240925124539.png]]

### Дополнительные настройки с помощью `sa_flags`

Поле `sa_flags` позволяет задать дополнительные параметры поведения обработчика:

1. **`SA_RESTART`** — если системный вызов был прерван сигналом, он будет автоматически перезапущен. Например, если сигнал поступил во время чтения из файла, вызов чтения продолжится после обработки сигнала. Если флаг не установлен, вызов завершится с ошибкой `EINTR`.
![[Pasted image 20240925124633.png]]

![[Pasted image 20240925124808.png]]

3. **`SA_RESETHAND`** — устанавливает обработчик сигнала так, что после первого срабатывания он сбросится на `SIG_DFL`, т.е. будет активен только один раз.

4. **`SA_NOCLDSTOP`** — игнорирование сигналов `SIGCHLD`, возникающих при остановке дочерних процессов.

Эти флаги помогают более гибко настроить поведение сигнальных обработчиков в зависимости от задач и требований программы.

### Классическая программа на обработку сигнала `SIGINT` (Ctrl+C)

Программа представляет собой пример классического использования сигнального обработчика для обработки сигнала `SIGINT`, который возникает при нажатии комбинации `Ctrl+C`. Разберём код по частям:

#### Код программы
```c
#include <stdio.h>
#include <signal.h>
#include <stdlib.h>
#include <unistd.h>

#define MAX_PUSHES 3

volatile unsigned int counter = 0;

void ctrlc_action(int sig, siginfo_t *info, void *foo) {
    if (counter < MAX_PUSHES) {
        counter++;
        printf("Pushed %u of %u allowed before exit\n", counter, MAX_PUSHES);
    } else {
        printf("Bye bye\n");
        exit(0);
    }
}

int main () {
    struct sigaction act = {0};
    sigemptyset(&act.sa_mask);
    act.sa_flags = SA_SIGINFO | SA_RESTART;
    act.sa_sigaction = ctrlc_action;
    sigaction(SIGINT, &act, NULL);
    while(1) {
        pause();  // Ожидание сигнала
    }
    return 0;
}
```

Вывод:

![[Pasted image 20240925131050.png]]

![[Pasted image 20240925131213.png]]
#### Пояснения и исправления

1. **Подключение заголовочных файлов:**
    ```c
    #include <stdio.h>     // Для функций printf и др.
    #include <signal.h>    // Для работы с сигналами
    #include <stdlib.h>    // Для exit и стандартных функций
    #include <unistd.h>    // Для pause и других POSIX-функций
    ```

2. **Макрос и глобальная переменная:**
    ```c
    #define MAX_PUSHES 3
    volatile unsigned int counter = 0;
    ```
    - `MAX_PUSHES` — максимальное количество нажатий `Ctrl+C`, после которых программа завершит свою работу.
    - `volatile` запрещает оптимизацию переменной `counter`, чтобы она всегда читалась из памяти, а не из регистра, что важно при работе с сигналами.

3. **Обработчик сигнала `SIGINT`:**
    ```c
    void ctrlc_action(int sig, siginfo_t *info, void *foo) {
        if (counter < MAX_PUSHES) {
            counter++;
            printf("Pushed %u of %u allowed before exit\n", counter, MAX_PUSHES);
        } else {
            printf("Bye bye\n");
            exit(0);
        }
    }
    ```
    - Функция `ctrlc_action` обрабатывает сигнал `SIGINT`.
    - При каждом нажатии `Ctrl+C` увеличивает счётчик `counter`. 
    - Если `counter` достигает значения `MAX_PUSHES`, программа завершает работу с сообщением "Bye bye".

4. **Инициализация структуры `sigaction`:**
    ```c
    struct sigaction act = {0};
    sigemptyset(&act.sa_mask);
    act.sa_flags = SA_SIGINFO | SA_RESTART;
    act.sa_sigaction = ctrlc_action;
    ```
    - **`sigemptyset(&act.sa_mask);`** очищает сигнальную маску для обработчика. Это означает, что никакие сигналы не блокируются во время работы обработчика.
    - **`act.sa_flags`**:
        - `SA_SIGINFO` позволяет использовать расширенную версию обработчика (принимающего три аргумента: `sig`, `info`, `foo`).
        - `SA_RESTART` автоматически перезапускает прерванные системные вызовы.
    - **`act.sa_sigaction`** указывает на функцию-обработчик.

5. **Регистрация обработчика:**
    ```c
    sigaction(SIGINT, &act, NULL);
    ```
    - Устанавливает обработчик `ctrlc_action` для сигнала `SIGINT`.

6. **Основной цикл программы:**
    ```c
    while(1) {
        pause();  // Ожидание сигнала
    }
    ```
    - Функция `pause()` переводит процесс в состояние ожидания до получения сигнала.
    - После каждого нажатия `Ctrl+C` (получения сигнала `SIGINT`) выполняется обработчик.

7. **Проблемы с `printf` в обработчике:**
    - `printf` использует буферизацию. Вызов `printf` в обработчике может привести к некорректной работе, если обработчик прервал выполнение другой части кода, которая использовала `printf`.
    - Если нужна корректная работа, следует использовать функции, не зависящие от буферизации, например, `write` из `unistd.h`.

8. **Особенности поведения:**
    - По умолчанию, сигнал, который был установлен как обрабатываемый, добавляется в сигнальную маску на время выполнения обработчика, чтобы избежать повторного вызова обработчика для этого же сигнала.


### Программа 2 (Парадокс звездочек)

#### Описание программы

Программа демонстрирует поведение функции `fork()` и проблемы, связанные с буферизацией вывода в `printf()`. В результате выполнения создаётся несколько процессов, каждый из которых выводит на экран символ `*`. Из-за особенностей буферизации вывод может оказаться неожиданным. Давайте рассмотрим работу программы по шагам:

#### Код программы

```c
#include <unistd.h>
#include <stdio.h>
#include <sys/wait.h>

int main() {
    printf("* ");    // Печать звёздочки без перевода строки
    fork();          // Первый вызов fork()
    fork();          // Второй вызов fork()
    
    wait(NULL);      // Ожидание завершения дочернего процесса
    wait(NULL);      // Ожидание завершения второго дочернего процесса
    
    // printf("pid = %d, ppid = %d\n", (int)getpid(), (int)getppid());
    return 0;
}
```

#### Проблема «лишних звёздочек»

При выполнении программы `fork()` создаёт новый процесс, копируя всю память родительского процесса, включая буфер вывода `stdout`. Если в буфере уже был символ `*` и `\n` не было использовано, то каждый новый процесс выведет его повторно. Это приводит к множественному выводу символа `*` на экран.

#### Почему это происходит?

- `printf()` выводит символы в буфер, а не сразу на экран.
- `fork()` копирует память родительского процесса, в том числе содержимое буферов. Если буфер не очищен (т.е. не сброшен на экран), то каждый процесс-ребёнок унаследует его содержимое.
- Без явного сброса буфера (`fflush(stdout);`) или использования перевода строки (`\n`) в `printf()`, символы выводятся повторно.

#### Решение проблемы

Чтобы избежать вывода «лишних звёздочек», необходимо явно сбрасывать буфер перед вызовом `fork()`:

```c
#include <unistd.h>
#include <stdio.h>
#include <sys/wait.h>

int main() {
    printf("* ");
    fflush(stdout);  // Сбрасываем буфер, чтобы '*' был выведен на экран

    fork();          // Первый вызов fork()
    fork();          // Второй вызов fork()
    
    wait(NULL);      // Ожидание завершения дочернего процесса
    wait(NULL);      // Ожидание завершения второго дочернего процесса

    printf("pid = %d, ppid = %d\n", (int)getpid(), (int)getppid()); // Печать идентификаторов процессов
    return 0;
}
```

#### Пояснение к исправлениям

1. **Очистка буфера вывода:**
    ```c
    fflush(stdout);
    ```
    - После вызова `printf("* ")` происходит сброс буфера, чтобы символ `*` был сразу выведен на экран.
    - Это предотвращает копирование несброшенного буфера в дочерние процессы, что устраняет многократный вывод символа `*`.

2. **Использование `wait(NULL);`:**
    - Дважды вызывается функция `wait(NULL);`, чтобы гарантировать, что родительский процесс дождётся завершения обоих дочерних процессов.
    - Каждый вызов `fork()` создаёт новый процесс, поэтому после двух `fork()` у нас получается четыре процесса, включая родительский.

3. **Печать идентификаторов процессов:**
    ```c
    printf("pid = %d, ppid = %d\n", (int)getpid(), (int)getppid());
    ```
    - Выводит идентификаторы текущего процесса (`pid`) и его родительского процесса (`ppid`). Эта информация помогает понять, какой процесс исполняет данную строку.

#### Общее поведение программы

- Программа начинается с вывода `* `.
- После первого `fork()` создаётся новый процесс, и обе программы (родительская и дочерняя) продолжают выполнение, начиная с того же места — со второго вызова `fork()`.
- После второго `fork()` в общей сложности будет четыре процесса (один родительский и три дочерних).
- С каждым вызовом `wait(NULL);` родительский процесс будет ожидать завершения одного из дочерних процессов.
- В итоге на экране будет отображено количество `*`, соответствующее количеству дочерних процессов, плюс одна звёздочка от родительского процесса.

Использование `fflush(stdout);` и вывод процессных идентификаторов (`pid`, `ppid`) позволяет лучше понять и контролировать поведение программы, особенно при работе с `fork()` и многопоточными процессами.


### Файловая система

Файловая система в UNIX представляет собой абстракцию, которая обеспечивает удобный и стандартизированный интерфейс для работы с различными типами данных и устройств. Она имеет несколько ключевых особенностей:

1. **Иерархическая структура:**
    - Файловая система организована в виде дерева, с корневым каталогом `/`, от которого растут все остальные каталоги и файлы.

2. **Vnode (винод) и vinode:**
    - Каждая файловая система должна предоставлять минимальный набор информации для управления объектами (файлами и каталогами). Эта информация организована в структуре, называемой vnode. Она абстрагирует взаимодействие с конкретными драйверами и устройствами, предоставляя единый интерфейс для доступа к объектам файловой системы.

3. **Символьные ссылки и множественные имена:**
    - В UNIX-файловой системе один и тот же физический объект (например, файл) может иметь несколько имён в разных каталогах. Это достигается с помощью создания «жёстких ссылок» на файл. Жёсткие ссылки позволяют нескольким путям указывать на один и тот же inode.

4. **Монтирование и отмонтирование:**
    - UNIX поддерживает операцию монтирования, которая позволяет «приклеить» одну файловую систему к другой. Например, мы можем смонтировать файловую систему на устройство `/dev/sdb1` в каталог `/mnt/usb`, тем самым создавая новую ветвь в дереве файловой системы. Когда происходит монтирование, старое содержимое каталога `/mnt/usb` становится недоступным до тех пор, пока не произойдёт отмонтирование.

#### Системный вызов `mount`

1. **Точка монтирования:**
    - Это путь в дереве файловой системы, куда будет присоединено новое устройство или файловая система. Например, `/mnt/usb`.

2. **Устройство для монтирования:**
    - Это может быть физическое устройство (например, `/dev/sda1`), виртуальная файловая система (например, `proc` или `sys`), или сетевой ресурс. В некоторых случаях устройство может отсутствовать, например, для псевдофайловых систем.

3. **Драйвер файловой системы:**
    - Определяет тип файловой системы (например, ext4, ntfs, nfs) и отвечает за преобразование содержимого устройства в набор каталогов и файлов. Драйвер предоставляет интерфейс для выполнения операций чтения и записи, а также для управления метаданными файловой системы.

4. **Опции монтирования:**
    - Позволяют задать дополнительные параметры, такие как режим доступа (только для чтения или чтения/записи), использование кеширования и управление ошибками. Например, опция `remount` используется для перезагрузки монтированной файловой системы с новыми параметрами.

    - В случае ошибок можно задать опцию, при которой файловая система автоматически монтируется в режиме `read-only` для предотвращения дальнейших повреждений.

    - Линукс позволяет монтировать один каталог поверх другого. Это может использоваться, например, при установке программного обеспечения, когда нужно временно подменить определённые каталоги для совместного использования между основной системой и установщиком.

![[Pasted image 20240925134736.png]]

#### Типы файлов и объектов файловой системы

1. **Регулярные файлы:**
    - Это основные объекты, хранящие данные в виде последовательности байт. Программы и документы — примеры регулярных файлов.

2. **Каталоги:**
    - Каталог содержит ссылки на другие файлы и каталоги. В каждом каталоге есть две обязательные записи:
        - `.` — ссылка на сам каталог.
        - `..` — ссылка на родительский каталог. В корневом каталоге `..` ссылается на самого себя.

3. **Символические ссылки:**
    - Это специальные файлы, которые содержат путь к другому файлу или каталогу. Ядро распознаёт их и автоматически перенаправляет доступ к целевому объекту.

4. **Файлы устройств:**
    - Представляют собой интерфейсы для взаимодействия с устройствами (например, `/dev/sda` для жёсткого диска). Они связываются с драйверами устройств, позволяя выполнять операции чтения, записи и управления устройствами.

5. **FIFO (именованные каналы):**
    - Обеспечивают межпроцессное взаимодействие, позволяя процессам обмениваться данными через файловую систему.

6. **Сокеты (семейство PF_UNIX):**
    - Используются для межпроцессного взаимодействия, обеспечивая передачу данных между процессами в одной системе через сокеты файловой системы.

#### Виртуальные индексные дескрипторы (vnode)
Основной задачей vnode является предоставление единообразного интерфейса для всех файловых систем, поддерживаемых операционной системой. Независимо от того, с каким типом файловой системы работает пользователь, `vnode` позволяет работать с файлами и каталогами одинаково.

Использование vnode помогает организовать эффективное взаимодействие между различными компонентами операционной системы и обеспечивает высокую степень совместимости и абстракции при работе с файлами и устройствами.

### Файлы устройств

Файлы устройств в UNIX/Linux используются для доступа к оборудованию (устройствам) и другим системным ресурсам через файловую систему. Они находятся в каталоге `/dev` и представляют собой специальные файлы, которые обеспечивают взаимодействие между приложениями и драйверами устройств. 

#### Типы файлов устройств

1. **Символьные устройства (c):**
    - Символьные устройства обеспечивают посимвольный доступ к данным. Примером символьного устройства является последовательный порт (`/dev/ttyS0`) или терминал (`/dev/tty`).
    - Операции чтения и записи выполняются по одному байту, что удобно для работы с такими устройствами, как клавиатура, мышь, или последовательные порты.

2. **Блочные устройства (b):**
    - Блочные устройства обеспечивают доступ к данным блоками фиксированного размера. Примером блочного устройства является жёсткий диск (`/dev/sda`) или флеш-накопитель.
    - Эти устройства поддерживают операции случайного доступа, позволяя быстро читать и записывать большие объёмы данных.

#### Мажорный и минорный номера

1. **Мажорный номер:**
    - Мажорный номер идентифицирует тип устройства и определяет драйвер, который будет использоваться для взаимодействия с этим устройством. 
    - Он указывает на группу устройств, связанных с одним и тем же драйвером, например, все жёсткие диски могут иметь один и тот же мажорный номер.

2. **Минорный номер:**
    - Минорный номер используется для идентификации конкретного устройства в пределах группы, определяемой мажорным номером.
    - Например, если мажорный номер определяет группу жёстких дисков, то минорный номер может указывать конкретный диск или раздел на этом диске.

![[Pasted image 20240925140808.png]]

Пример: 
```bash
ls -l /dev/sda
brw-rw---- 1 root disk 8, 0 Sep 26 12:34 /dev/sda
```
В этом примере:
- `b` — блочное устройство,
- `8` — мажорный номер (идентификатор драйвера),
- `0` — минорный номер (конкретное устройство или его часть)