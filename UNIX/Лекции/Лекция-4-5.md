
---

### Документация

1. **Команда `info`** — это текстовая система документации, которая предоставляет более подробную информацию о программах. Хотя она не очень популярна, она может быть полезна для получения подробных справочных материалов. Например, `info coreutils` покажет документацию о наборе утилит coreutils.
   
2. **Команда `man`** — основная команда для просмотра документации в UNIX. Файлы документации хранятся в каталоге `/usr/share/man`, но они могут быть и в других местах. Команда `man` использует специальную переменную окружения `manpath` для поиска этих файлов, чтобы найти документацию не только в стандартных местах.

3. **Формат файлов `man`** — файлы с расширением `.gz` сжаты с помощью `gzip`. Например, `ls.1.gz` — это сжатая документация для команды `ls`, относящаяся к **первой секции** документации. Чтобы разжать и посмотреть файл, можно использовать команду `gunzip ls.1.gz`. Когда ты запускаешь `man`, он распознает этот формат и выводит текстовый файл.

4. **Секции документации**:
   - **1**: Пользовательские программы. Пример: `man ls` покажет документацию о команде `ls`.
   - **2**: Системные вызовы. Например, `man 2 open` покажет описание системного вызова `open`.
   - **3**: Библиотечные функции, такие как `printf` или `malloc`. Пример: `man 3 printf`.
   - **4**: Специальные файлы, связанные с устройствами или файловыми системами.
   - **5**: Конфигурационные файлы, например, `man 5 fstab`.
   - **6**: Игры, если они установлены.
   - **7**: Прочие материалы, такие как макроопределения или форматы файлов.
   - **8**: Административные команды и утилиты. Например, `man 8 reboot`.
   - **9**: Документация по ядру и внутренним функциям.

5. **Дополнительная документация**:
   - **/usr/share/doc** — здесь хранятся дополнительные документы, но они не структурированы как `man`. Это может включать лицензии, README и прочие файлы, относящиеся к установленным программам.
   - Для поиска по документации можно использовать команду `apropos`. Например, `apropos network` покажет список всех man-страниц, связанных с сетью.

---

### Shell

1. **Shell** — это интерфейс командной строки, который работает как язык программирования. Один из популярных Shell — это **Bash**. Чтобы узнать подробности, можно использовать команду `man bash`, которая откроет руководство по его использованию.

2. **Пример использования `man` с конвейером**:
   - Команда `man bash | a2ps > bash.eps` отправит вывод команды `man bash` в утилиту **a2ps** (форматирует текст для печати) и сохранит результат в файл `bash.eps`.
   - **Конвейер** (вертикальная палка `|`) перенаправляет вывод одной команды в качестве ввода для другой. Например, команда `ls | wc` передаст список файлов, полученный от команды `ls`, в команду `wc`, которая подсчитает количество строк, слов и символов.
   - **Перенаправление вывода**: `>` — перезаписывает файл, `>>` — добавляет информацию в конец файла. Пример: `echo "hello" > file.txt` создаст файл и запишет туда "hello", а `echo "world" >> file.txt` добавит "world" в конец файла.
   - **Перенаправление ошибок**: `2>` — перенаправляет стандартный поток ошибок. Пример: `command 2> error.log` — отправит ошибки в файл `error.log`.
   - **Объединение потоков вывода и ошибок**: `2>&1` — это синтаксис для объединения стандартного вывода и ошибок в один поток. Пример: `command > output.log 2>&1` запишет как вывод, так и ошибки в один файл.

---

### Пример работы команды `ls | wc`
Эта команда выводит список файлов с помощью `ls` и передает этот список в `wc`, которая подсчитывает количество строк, слов и символов. Это полезно для того, чтобы быстро узнать, сколько файлов находится в текущем каталоге.


### Полезные команды

1. **sort** — сортирует строки текста. Можно сортировать по числам или лексикографически. Пример: `sort file.txt` отсортирует строки в файле.
2. **wc (word count)** — считает количество строк, слов и символов в файле или вводе. Пример: `wc file.txt` покажет количество строк, слов и байт в файле.
3. **cat (concatenate)** — выводит содержимое файла или ввод на экран. Пример: `cat file.txt` покажет содержимое файла `file.txt`.
4. **cut** — вырезает определенные части строк. Полезно для обработки колонок в текстовых файлах. Пример: `cut -d: -f1 /etc/passwd` вырежет первый столбец из файла `/etc/passwd`, используя `:` как разделитель.
5. **tr** — преобразует или удаляет символы в строках. Пример: `tr 'a' 'A'` заменит все маленькие буквы "a" на заглавные "A" в вводе.
6. **ed** — древний текстовый редактор, который работает в командной строке. Практически не используется.
7. **sed (stream editor)** — мощный редактор потоков текста, поддерживающий регулярные выражения. Пример: `sed 's/old/new/g' file.txt` заменит все вхождения слова "old" на "new" в файле.
8. **gawk** — утилита для обработки текста с поддержкой собственного языка программирования. Пример: `gawk '{print $1}' file.txt` выведет первый столбец каждой строки файла.

---

### Консольные текстовые редакторы

1. **vim** — один из самых мощных и сложных текстовых редакторов. Очень популярен среди программистов и системных администраторов.
2. **emacs** — текстовый редактор с огромными возможностями. Включает встроенный интерпретатор для написания и выполнения программ прямо в редакторе.
3. **nano** — простой и легкий редактор, идеален для начинающих.
4. **inc.edit** — менее известный редактор, но также удобен.
5. **joe** — текстовый редактор с интерфейсом, напоминающим старые редакторы DOS.

---

### Текстовые браузеры

1. **links**, **lynx**, **elinks** — текстовые браузеры, которые позволяют просматривать веб-страницы без графического интерфейса. Полезны для работы на серверах или в консольных средах.
2. **wget** — утилита для скачивания файлов через HTTP, FTP и другие протоколы. Пример: `wget http://example.com/file.zip` скачает файл с указанного URL.
3. **curl** — еще одна утилита для скачивания файлов и отправки запросов по HTTP/HTTPS. Пример: `curl -O http://example.com/file.zip` скачает файл.

---

### Управление процессами

Управление процессами в UNIX-системах позволяет следить за состоянием выполняемых задач, менять их приоритет, завершать, а также анализировать их зависимости от библиотек.

1. **tee input.txt | ./my_programm**  
   - Эта команда использует утилиту `tee`, которая записывает ввод в файл (в данном случае `input.txt`) и одновременно передает этот же ввод в стандартный поток следующей команды (запускает `./my_programm`). Это полезно, если нужно сохранить входные данные программы, не прерывая её работу.

2. **Список процессов** — Для просмотра текущих процессов в системе можно использовать команду `ps`:
   - `ps` — выводит список процессов, запущенных пользователем в текущем сеансе. Пример: `ps aux` выведет все активные процессы с их владельцами, потреблением ресурсов и идентификаторами (PID).
   - Полезные опции:
     - `-a` — покажет все процессы, запущенные пользователями, кроме сеансов `tty`.
     - `-u` — покажет процессы с информацией об их владельцах.
     - `-x` — покажет процессы, не привязанные к конкретному терминалу.

3. **top**  
   - `top` — это интерактивная утилита для мониторинга системных процессов в реальном времени. Она показывает список активных процессов, их использование процессора и памяти, и позволяет выполнять действия с процессами, например, убивать их. Для выхода из `top`, нажмите `q`.
   
4. **ntop**  
   - `ntop` — это инструмент для мониторинга сетевых процессов. Он показывает информацию о сетевой активности в реальном времени, включая использование пропускной способности, количество пакетов, переданных через интерфейсы, и данные по сетевым подключениям.

5. **kill**  
   - `kill` — команда для завершения процессов по их идентификатору (PID). Пример: `kill 1234` завершит процесс с PID 1234. По умолчанию отправляется сигнал `SIGTERM`, который аккуратно завершает процесс.
   - **kill -9** — это отправка сигнала `SIGKILL`, который принудительно завершает процесс. Пример: `kill -9 1234`.
   
6. **killall**  
   - `killall` — завершает все процессы с определенным именем. Пример: `killall my_programm` завершит все запущенные экземпляры программы `my_programm`.

7. **ldd исполняемый файл**  
   - `ldd` — утилита, которая показывает динамические библиотеки, от которых зависит исполняемый файл. Пример: `ldd my_programm` выведет список всех библиотек, необходимых для работы программы, и их зависимости от других библиотек.

8. **nice**  
   - `nice` — позволяет запустить процесс с измененным приоритетом. Чем ниже приоритет (числовое значение), тем больше ресурсов получает процесс. Пример: `nice -n 10 ./my_programm` запустит программу `my_programm` с приоритетом 10 (меньший приоритет означает меньшее использование ресурсов).

9. **renice**  
   - `renice` — изменяет приоритет уже запущенного процесса. Пример: `renice 5 1234` изменит приоритет процесса с PID 1234 на 5. Это полезно для оптимизации работы системы, изменяя приоритет процессов на лету.

---

### Аппаратура

Компьютерная аппаратура — это основа работы любой вычислительной системы. И действительно, если говорить о физической части компьютера, самой важной его составляющей является **материнская плата**.

#### Материнская плата

Материнская плата (или **motherboard**) представляет собой ключевую компоненту, на которой строится вся вычислительная система. Она связывает все другие части компьютера через различные шины и контроллеры.

##### Физический уровень

На физическом уровне материнская плата состоит из множества проводников, которые называют дорожками. Эти дорожки могут быть очень тонкими и представляют собой медные проводники, встраиваемые в многослойные слои текстолита. Каждая дорожка проводит электрические сигналы, соединяя компоненты между собой. Разные уровни платы могут содержать дорожки для различных шины или напряжений, которые должны быть изолированы друг от друга.

![[Pasted image 20240918192842.png]]

![[Pasted image 20240918192812.png]]

![[Pasted image 20240918192859.png]]

##### Логический уровень

1. **Контроллер внешних устройств**:  
   На материнской плате находятся контроллеры, отвечающие за работу внешних устройств, таких как USB-шины, сетевые карты и другие периферийные устройства. Эти контроллеры позволяют устройствам общаться с процессором и памятью через соответствующие шины.  

2. **Системные шины**:  
   Главная задача системной шины (System Bus) — связывать процессор с другими важными компонентами системы, например, с оперативной памятью и кэшем. Шины обеспечивают высокоскоростной обмен данными между процессором и оперативной памятью.  

3. **Абоненты на шине**:  
   Помимо процессора и кэша, на шину могут быть подключены и другие устройства, например, контроллеры оперативной памяти, графические карты, накопители данных (SSD, HDD) и прочие компоненты. Шина позволяет обмениваться данными между этими устройствами.  

4. **Контроллеры шин**:  
   Контроллеры шин отвечают за координацию передачи данных по этим проводникам. Они задают тактовую частоту для синхронизации передачи информации между устройствами, что обеспечивает корректное взаимодействие всех компонентов системы.

---

Архитектура материнской платы организована по **иерархической шинной структуре**, где шины имеют разные уровни скорости и предназначения. Быстрые шины используются для передачи данных между процессором и кэшем или памятью, в то время как более медленные шины связывают менее критичные устройства (например, USB, Ethernet).

---

### Оперативная память

Оперативная память (ОЗУ) — это ключевой компонент компьютерной системы, который напрямую влияет на производительность компьютера, так как она обеспечивает доступ к данным, которые активно используются процессором.

#### 1. Частота

Частота оперативной памяти указывает, как быстро она может обрабатывать данные и передавать их процессору. Чем выше частота, тем больше данных можно обработать за один такт. Это критично для приложений, требующих высокой пропускной способности, таких как игры, программирование, обработка видео.

#### 2. Объем

Объем ОЗУ определяет, сколько данных может быть одновременно загружено в память для обработки. Например, 4 x 4 ГБ (в сумме 16 ГБ) или 1 x 64 ГБ. В многоканальных системах (например, 4-канальных) предпочтительно использовать несколько модулей с одинаковым объемом, чтобы задействовать параллелизм (см. ниже).

#### 3. Тип

Тип ОЗУ обычно определяется поколением памяти. Например, DDR3, DDR4, DDR5. Эти типы памяти различаются по скорости, потребляемой энергии и плотности ячеек, что делает более новые типы памяти предпочтительными для современных систем.

#### 4. Принцип параллелизма при чтении/записи

Современные системы используют многоканальную память (например, 2- или 4-канальные), что позволяет процессору одновременно обращаться к нескольким модулям памяти. Это значительно повышает производительность за счет параллельного выполнения операций чтения и записи.

##### Пример:  
В 4-канальной системе, если у вас 4 модуля по 4 ГБ, каждый модуль работает независимо от других. Это позволяет одновременно читать или записывать данные на разные модули, увеличивая общую пропускную способность.

![[Pasted image 20240918193009.png]]

#### 5. ECC, не ECC, и тегированная память

- **ECC (Error Correcting Code)**:  
  ECC-память содержит дополнительные биты, которые используются для обнаружения и исправления ошибок. Это важно для серверов и критически важных систем, где даже одна ошибка памяти может привести к катастрофическим последствиям (например, сбои программы, потеря данных). ECC более медленная и дорогая, но гарантирует защиту от случайных ошибок.

- **Не ECC**:  
  Обычная память без функции коррекции ошибок. Обычно используется в настольных компьютерах и ноутбуках, где не столь критичны случайные ошибки.

- **Тегированная память**:  
  Это концепция, где каждому блоку памяти может быть присвоен определённый тег, используемый для оптимизации работы системы, например для безопасности или разделения памяти между различными процессами. Системы с тегированной памятью могут отслеживать и предотвращать ошибки доступа.

![[Pasted image 20240918193040.png]]

#### 6. Тайминги

Тайминги — это задержки, связанные с доступом к памяти. Чем меньше тайминги, тем быстрее память может выполнять операции. Тайминги важны для производительности, особенно при высоких частотах ОЗУ.

- **tread**:  
  Это время, которое требуется для получения данных из ячейки памяти. Оно указывает, сколько тактов должно пройти до того, как процессор сможет начать чтение данных.

- **twrite**:  
  Время, которое требуется для записи данных в память. Оно включает время, необходимое для завершения операции записи и разблокировки процессора.

- **tcycle**:  
  Время, которое должно пройти до повторного обращения к той же ячейке памяти. Это значение обычно больше, чем `tread` и `twrite`, и может отличаться для операций чтения и записи.

- **trefresh**:  
  Это интервал времени, в течение которого память автоматически обновляет свои данные, чтобы избежать потери информации. ОЗУ использует электрические заряды для хранения данных, которые со временем могут разряжаться. Чтобы предотвратить это, память периодически обновляет свои ячейки.

#### Пример расслоения памяти

Чтобы избежать блокировки при последовательных обращениях к памяти, банки памяти нумеруются так, чтобы смежные адреса находились в разных банках. Это позволяет системе обращаться к разным банкам параллельно, повышая общую производительность системы. Если бы вся память была в одной банке, это создавало бы "узкое место" для операций чтения и записи.

![[Pasted image 20240918193028.png]]

#### Подробней про trefresh

Механизм **trefresh** (время обновления) необходим для поддержания целостности данных в ячейках DRAM. Данные в DRAM хранятся в виде электрических зарядов в конденсаторах. Однако эти заряды со временем утрачиваются (разряжаются), что может привести к потере данных, если не предпринять шаги по их восстановлению.

##### График: напряжение и время

По оси **OY** откладывается **напряжение**, а по оси **OX** — **время**. На этом графике видно, как напряжение в ячейке памяти изменяется со временем, если не предпринимать никаких действий.

![[Pasted image 20240918193257.png]]

1. **Граница 1**:  
   Это пороговое напряжение, при котором ячейка памяти считается хранящей "единицу". Все, что выше этой границы, интерпретируется как логическая "1".

2. **Граница 0**:  
   Это пороговое напряжение, ниже которого ячейка памяти интерпретируется как хранящая "ноль". Все, что ниже этой границы, считается логической "0".

3. **Серая зона**:  
   Между границами "1" и "0" находится область неопределенности — **серая зона**. Если напряжение в ячейке упадет в эту зону, то система не сможет точно определить, какой бит (0 или 1) хранится в ячейке. Это ведет к ошибкам в данных.

##### Почему нужно обновление (trefresh)?

Когда ячейка памяти хранит данные, напряжение в ней **естественным образом падает со временем**. Это обусловлено тем, что заряды в конденсаторах постепенно утрачиваются. Если не производить периодическое обновление, напряжение может опуститься в серую зону, что приведет к потере данных.

##### Роль trefresh

**trefresh** — это время, в течение которого память обновляет свое напряжение в ячейках, чтобы избежать попадания в серую зону. Система регулярно "освежает" заряд в ячейке, повышая его до границы 1 или 0, чтобы предотвратить потерю данных.

- Если напряжение **приближается к серой зоне**, во время trefresh оно обновляется до нужного уровня (до границы 1 или 0). Это позволяет избежать некорректного распознавания данных.
- Если происходит **резкое падение напряжения** в серую зону (например, из-за скачка или сбоя), система может использовать trefresh, чтобы восстановить уровень напряжения и предотвратить ошибки.

![[Pasted image 20240918193315.png]]

##### Зависимость от качества ОЗУ

- Чем **качественнее материалы** оперативной памяти, тем медленнее происходит разрядка и лучше кривая напряжения, соответственно, реже требуется обновление.
- Время обновления trefresh может варьироваться в зависимости от физических характеристик ОЗУ: чем лучше материалы и дизайн, тем реже нужно обновлять данные.

---

### Кэш-память

Кэш — это быстрая память, находящаяся между процессором и оперативной памятью (ОЗУ). Её основная задача — ускорить доступ процессора к часто используемым данным, минимизируя задержки при обращении к медленной ОЗУ.

### Принцип работы кэша

Кэш организован в виде **строк кэша** (cache lines). Строка кэша — это блок данных фиксированной длины, который загружается в кэш целиком. Вместо того, чтобы загружать по одному байту, кэш считывает несколько ячеек памяти одновременно, что оптимизирует время доступа.

---

### Уровни кэша

Современные процессоры имеют **многоуровневую систему кэширования** (L1, L2, L3), где каждый уровень имеет свои особенности, скорость и объем.

---

#### **Кэш L1 (уровень 1)**

- **Размер**: Обычно очень мал — от 16 до 128 КБ на ядро процессора.
- **Скорость**: Самый быстрый из всех уровней кэша, он работает почти на той же скорости, что и процессор.
- **Типы**: Кэш L1 обычно разделен на два подтипа:
  - **L1d**: Кэш данных (data cache) — хранит данные, к которым процессор часто обращается.
  - **L1i**: Кэш инструкций (instruction cache) — хранит инструкции, которые процессор выполняет.
  
Кэш L1 строится на той же элементной базе, что и регистры процессора (например, на основе SRAM — статической памяти). Он используется для минимизации времени доступа к инструкциям и данным, которые находятся "близко" к процессору, то есть часто используются в текущем контексте выполнения программы. Поскольку его объем мал, он имеет высокую скорость, но хранит лишь ограниченные объемы данных.

---

#### **Кэш L2 (уровень 2)**

- **Размер**: Больше, чем у L1, обычно от 256 КБ до нескольких МБ на ядро.
- **Скорость**: Медленнее L1, но всё же значительно быстрее, чем ОЗУ.
- **Назначение**: Кэш L2 является буфером между кэшем L1 и более медленными уровнями памяти, включая L3 и оперативную память. В большинстве современных процессоров L2 кэш индивидуален для каждого ядра.

В отличие от L1, кэш L2 может хранить больше данных и синхронизировать работу нескольких ядер процессора. Он также занимается более сложными алгоритмами управления, такими как предсказание, какие данные будут необходимы ядрам в будущем. За счет этого L2 имеет более сложную организацию и больший размер тэгов (идентификаторов ячеек).

---

#### **Кэш L3 (уровень 3)**

- **Размер**: Существенно больше, чем L1 и L2, может достигать десятков МБ и обычно делится между всеми ядрами процессора (кэш общего назначения).
- **Скорость**: Медленнее, чем L1 и L2, но быстрее, чем оперативная память.
- **Назначение**: Кэш L3 работает как промежуточное звено между процессором и основной памятью. Он хранит данные, которые могут быть востребованы процессором, если они не были найдены в кэше L1 или L2.

Кэш L3 может использовать разные стратегии записи:
- **Отложенная запись (write-back)**: Данные изменяются только в кэше, а запись в основную память откладывается до тех пор, пока это необходимо. Это позволяет избежать частых обращений к медленной оперативной памяти.
- **Сквозная запись (write-through)**: Данные одновременно записываются как в кэш, так и в оперативную память. Этот подход обеспечивает согласованность данных, но может быть медленнее, чем отложенная запись, поскольку требует больше операций записи.

---

### Итог

- **L1**: Быстрая, но маленькая память, работает с небольшими объемами данных и инструкций, доступ к которым требуется мгновенно.
- **L2**: Больше и медленнее L1, но все еще значительно быстрее, чем оперативная память, синхронизирует работу ядер.
- **L3**: Большой кэш, общий для всех ядер, служит связующим звеном между процессором и оперативной памятью.

![[Pasted image 20240918193727.png]]


---

## 1. **Регистры процессора**

Регистры — это небольшие области памяти внутри процессора, которые обеспечивают быструю обработку данных. Они разделяются на несколько категорий:

### а) **Регистры общего назначения (General-Purpose Registers)**

Эти регистры используются для хранения данных, которые обрабатываются процессором во время выполнения инструкций. Например, в архитектуре x86 это регистры **AX**, **BX**, **CX**, **DX**. Они могут хранить целые числа, адреса памяти и быть использованы для выполнения арифметических и логических операций.

### б) **Служебные регистры**

Служебные регистры выполняют вспомогательные функции, такие как управление программным стеком, указатели на инструкции и адреса данных. Примеры:
- **EIP (Instruction Pointer)**: указывает на следующую инструкцию для выполнения.
- **ESP (Stack Pointer)**: указывает на вершину стека.

### в) **Специальные регистры**

Эти регистры нужны для управления низкоуровневыми функциями процессора, такими как управление памятью и прерываниями. Их используют операционная система и сам процессор. Примеры:
- **Сегментные регистры**: используются для работы с сегментированной памятью.
- **Контрольные регистры (CR0, CR3 и т.д.)**: управляют такими функциями, как виртуальная память и защита.
- **Регистры прерываний**: помогают обрабатывать прерывания от внешних устройств.
- **Регистры отладки (DR)**: используются для настройки точек останова и трассировки программы.
- **Теневые регистры (Shadow Registers)**: содержат копии важных регистров и используются для восстановления их значений в случае сбоев.

---

## 2. **Режимы работы процессора**

Процессор поддерживает несколько режимов работы, чтобы разделять привилегированные и непривилегированные задачи.

### а) **Привилегированный режим (Kernel Mode)**

Этот режим позволяет выполнять критические инструкции, которые управляют работой системы. Операционная система использует этот режим для выполнения задач, которые могут затронуть работу всего компьютера, например:
- **Запись в привилегированные регистры**: Например, регистр **IDTR** (Interrupt Descriptor Table Register), который управляет таблицей прерываний.
- **Доступ к адресам памяти**: Диапазоны адресов, доступные процессору, отличаются для привилегированных и непривилегированных режимов. В привилегированном режиме можно обращаться к областям памяти, запрещённым для обычных программ.

### б) **Пользовательский режим (User Mode)**

Этот режим ограничивает доступ программ к критическим ресурсам системы. Программы могут выполнять стандартные инструкции, такие как:
- **Арифметические операции**.
- **Перемещение данных с помощью инструкции `mov`**.

---

## 3. **Контроль прерываний**

Прерывания — это сигналы от внешних или внутренних устройств, которые требуют немедленного внимания процессора. Примеры прерываний:
- **Аппаратные прерывания**: генерируются устройствами ввода-вывода, например клавиатурой или сетевым адаптером.
- **Программные прерывания**: генерируются программой для обращения к функциям операционной системы (системные вызовы).

Процессор использует таблицу прерываний (IDT — Interrupt Descriptor Table) для определения, как обрабатывать каждое прерывание. После получения прерывания он приостанавливает текущее выполнение программы и вызывает соответствующий обработчик.

---

## 4. **Ввод/вывод (I/O)**

Ввод и вывод данных осуществляется процессором для взаимодействия с внешними устройствами. Для этого предусмотрены несколько механизмов:

### 1) **Отображение регистров внешних устройств на виртуальную память**

Некоторые устройства отображают свои регистры управления в виртуальное адресное пространство, что позволяет процессору работать с ними через обычные операции чтения/записи в память.

### 2) **Захват оперативной памяти устройствами (DMA)**

Механизм **DMA (Direct Memory Access)** позволяет внешним устройствам напрямую записывать данные в оперативную память, минуя процессор. Это разгружает процессор и повышает общую производительность системы.

### 3) **Инструкции для ввода/вывода данных**

Процессор может использовать специальные инструкции, такие как **`in`** и **`out`**, для взаимодействия с портами ввода-вывода. Эти инструкции читают или записывают данные в порты, через которые подключены внешние устройства.

### 4) **Механизм DMA**

DMA позволяет устройствам, например, сетевым адаптерам или дискам, передавать данные напрямую в оперативную память без участия процессора. Процессор инициирует операцию DMA, а затем устройство завершает передачу самостоятельно, уведомляя процессор прерыванием, когда передача завершена.
